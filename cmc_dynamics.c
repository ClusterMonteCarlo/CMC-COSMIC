/* -*- linux-c -*- */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include "cmc.h"
#include "cmc_vars.h"

/* destroys a binary; returns the index of the new star */
long destroy_binary(long kp)
{
	long kpp;

	/* destroy binary */
	star[kp].binind = 0;
	
	/* create new star, and assign some properties */
	kpp = create_star();

	star[kpp].m = binary[star[kp].binind].m2;
	star[kpp].binind = 0;

	return(kpp);
}

/* create a new star, returning its index */
long create_star(void)
{
	long kpp;
	
	/* account for new star */
	clus.N_STAR_NEW++;
	clus.N_MAX_NEW++;
	
	/* put new star at end */
	kpp = clus.N_MAX_NEW;

	return(kpp);
}

/* the next generation of perturb_stars() */
/* Sep 9, 2004: tested with relaxation only; yields core collapse time of Plummer model of 15.15 t_rh */
void perturb_stars_new(double dt, gsl_rng *rng)
{
	long j, si, si_minus_p, si_plus_p, N_LIMIT, p=20, k, kp, kpp, RepeatEncounter;
	double SaveDt, madhoc, S;
	double W, v[4], vp[4], w[4], phi, psi, beta, wp, w1[4], w2[4];
	double v_new[4], vp_new[4], vr_new, vt_new, vrp_new, vtp_new;
	double r, rp, rm, Dr, m, mp, w_new[4], R, Rp;
	double vr, vt, vrp, vtp, Ai;
	double P_enc, n_local, vcm[4], rcm;
	double sin2beta;

	/* set the (N-body) units, written in CGS */
	units_set();
	
	/* Masses such as star.m and binary.m1 and binary.m2 are not stored in code units, 
	   but rather in code units * clus.N_STAR.  This means that whenever you want to
	   calculate a quantity that involves masses and lengths, or masses and times, you
	   have to divide any masses in the expression by clus.N_STAR.  This is that 
	   factor.  */
	madhoc = 1.0/((double) clus.N_STAR);

	/* useful debugging */
	if (tcount == 1) {
		dprintf("MEGA_YEAR=%g\n", MEGA_YEAR);
		dprintf("SOLAR_MASS_DYN=%g\n", SOLAR_MASS_DYN);
		dprintf("initial_total_mass=%g\n", initial_total_mass);
		dprintf("units.t=%g YEAR\n", units.t/YEAR);
		dprintf("units.m=%g MSUN\n", units.m/MSUN);
		dprintf("units.l=%g PARSEC\n", units.l/PARSEC);
	}
	
	/* DEBUG */
	/*
	if (tcount == 50) {
		for (j=0; j<N_STAR_DIM; j++) {
			fprintf(stdout, "%ld %ld %g %g\n", j, star[j].id, star[j].r, star[j].m);
		}
		fprintf(stdout, "clus.N_STAR=%ld clus.N_STAR_NEW=%ld clus.N_MAX=%ld clus.N_MAX_NEW=%ld\n", 
			clus.N_STAR, clus.N_STAR_NEW, clus.N_MAX, clus.N_MAX_NEW);
		exit_cleanly(1);
	}
	*/
	/* DEBUG */

	SaveDt = dt;		/* Original dt provided, saved for repeated encounters, where dt is changed */
	Delta_BE_bb = 0.0;	/* Total energy generated by binary-binary interactions */
	Delta_BE_bs = 0.0;	/* Total energy generated by binary-single interactions */
	clus.N_MAX_NEW = clus.N_MAX+1;	/* keeps track of stars from disrupted binaries */

	/* set up the subcount timestep business */
	if (sub.count == 0) {
		N_LIMIT = clus.N_MAX;	/* do FULL time step */
	} else {
		N_LIMIT = sub.N_MAX;	/* do sub step only */
	}
	
	/* the big loop, with limits chosen so that we omit the last star if it is not paired */
	for (si=1; si<=N_LIMIT-N_LIMIT%2-1; si+=2) {
		if (si > sub.N_MAX) {	/* part of outer halo in a FULL time step */
			dt = sub.totaltime;
		} else {
			dt = SaveDt;
		}
		
		k = si;
		kp = si + 1;

		r = star[k].r;
		rp = star[kp].r;
		rm = (r + rp) / 2.0;
		vr = star[k].vr;
		vt = star[k].vt;
		vrp = star[kp].vr;
		vtp = star[kp].vt;
		Dr = fabs(rp - r);
		m = star[k].m;
		mp = star[kp].m;
		
		/* Compute relative speed W */
		phi = rng_t113_dbl() * 2.0 * PI;
		v[1] = vt;
		v[2] = 0.0;
		v[3] = vr;
		vp[1] = vtp * cos(phi);
		vp[2] = vtp * sin(phi);
		vp[3] = vrp;
		
		for (j = 1; j <= 3; j++) {
			w[j] = vp[j] - v[j];
		}
		W = sqrt(sqr(w[1]) + sqr(w[2]) + sqr(w[3]));
		if (W == 0.0) {
			eprintf("Star %ld : W = 0 in perturb_stars_new() - 2\n", si);
			eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
				si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
			exit_cleanly(1);
		}
		
		/* compute CM speed */
		for (j=1; j<=3; j++) {
			vcm[j] = (m * v[j] + mp * vp[j]) / (m + mp);
		}
		rcm = (m * r + mp * rp) / (m + mp);
		
		/* Compute local density */
		si_minus_p = si - p;
		si_plus_p = si + p + 1;
		if (si_minus_p < 0) {
			si_minus_p = 0;
			si_plus_p = 2 * p + 1;
		} else if (si_plus_p > N_LIMIT) {
			si_plus_p = N_LIMIT;
			si_minus_p = N_LIMIT - 2 * p - 1;
		}
		
		n_local = (2.0 * p) * 3.0 / (4.0 * PI * (cub(star[si_plus_p].r) - cub(star[si_minus_p].r)));
		
		if (star[k].binind > 0 && star[kp].binind > 0) {
			/* binary--binary cross section */
			S = 0.0;
		} else if (star[k].binind > 0 || star[kp].binind > 0) {
			/* binary--single cross section */
			S = 0.0;
		} else {
			/* single--single star physical collision cross section */
			R = star[k].rad;
			Rp = star[kp].rad;
			S = PI * sqr(R + Rp) * (1.0 + 2.0*madhoc*(m+mp)/((R+Rp)*sqr(W)));
			/* uncomment the next line to turn off collisions */
			/* S = 0.0; */
		}

		/* calculate encounter probability */
		P_enc = n_local * W * S * (dt * ((double) clus.N_STAR)/log(GAMMA*((double) clus.N_STAR)));
		
		/* warn if something went wrong with the calculation of Dt */
		if (P_enc >= 1.0) {
			wprintf("P_enc = %g >= 1!\n", P_enc);
		}

		/* do encounter or two-body relaxation */
		if (rng_t113_dbl() < P_enc) {
			/* do encounter */
			if (star[k].binind > 0 && star[kp].binind > 0) {
				/* binary--binary */
			} else if (star[k].binind > 0 || star[kp].binind > 0) {
				/* binary--single */
			} else {
				/* single--single */
				dprintf("single--single collision detected: id=%ld m=%g MSUN idp=%ld mp=%g MSUN\n",
					star[k].id, m * madhoc * units.m / MSUN, 
					star[kp].id, mp * madhoc * units.m / MSUN);
				
				kpp = create_star();

				/* conserve mass and momentum in collision */
				star[kpp].r = rcm;
				star[kpp].vr = vcm[3];
				star[kpp].vt = sqrt(sqr(vcm[1])+sqr(vcm[2]));
				star[kpp].m = m + mp;
				star[kpp].phi = potential(star[kpp].r);
				star[kpp].E = star[kpp].phi + 0.5*(sqr(star[kpp].vr) + sqr(star[kpp].vt));
				star[kpp].J = star[kpp].r * star[kpp].vt;
				star[kpp].EI = 0.0;
				/* Calculate internal energy assuming potential doesn't change during collision.
				   Should there be a factor of 1/2 for the potential energy? */
				star[kpp].Eint = star[k].Eint + star[kp].Eint 
					+ 0.5 * star[k].m * madhoc * (sqr(star[k].vr) + sqr(star[k].vt)) 
					+ 0.5 * star[kp].m * madhoc * (sqr(star[kp].vr) + sqr(star[kp].vt))
					- 0.5 * star[kpp].m * madhoc * (sqr(star[kpp].vr) + sqr(star[kpp].vt))
					+ 0.5 * star[k].m * madhoc * star[k].phi
					+ 0.5 * star[kp].m * madhoc * star[kp].phi
					- 0.5 * star[kpp].m * madhoc * star[kpp].phi;
				star[kpp].rnew = star[kpp].r;
				star[kpp].vrnew = star[kpp].vr;
				star[kpp].vtnew = star[kpp].vt;
				star[kpp].rOld = r;
				star[kpp].X = 0.0;
				star[kpp].r_peri = star[kpp].r;
				star[kpp].r_apo = star[kpp].r;
				star[kpp].interacted = 1;
				star[kpp].binind = 0;
				star[kpp].id = -5;
				
				/* the interacted flag has to be set to 1 for other routines to work properly */
				star[k].interacted = 1;
				star[kp].interacted = 1;
				
				/* remove the two merger progenitor stars */
				remove_star_center(k);
				remove_star_center(kp);
			}
		} else {
			/* do two-body relaxation */
			RepeatEncounter = 1;
			while (RepeatEncounter) {
				/* Stodolkiewicz calculation of beta */
				Ai = 3.0 * p * sqr(m + mp) / (cub(W) * (cub(star[si_plus_p].r) - cub(star[si_minus_p].r)));
				sin2beta = Ai * dt / clus.N_STAR;
				
				/* sometimes, sin2beta becomes > 1, so need to handle that differently */
				if (sin2beta <= 1) {	/* normal case -- only one encounter required */
					beta = 2.0 * asin(sqrt(sin2beta));
					/* POSIX standard is for asin to return a value between -PI/2 and PI/2 (inclusive) */
					if (beta > PI / 2) {
						beta = PI - beta;
					}
					RepeatEncounter = 0;
					dt = SaveDt;	/* reset dt to original value */
				} else {	/* abnormal case -- compute multiple encounters */
					beta = PI;
					sin2beta = 1.0;	/* use beta = PI for the first encounter */
					dt = dt / Ai;	/* reduce Dt by Ai for the next encounter */
					RepeatEncounter = 1;
				}
				
				wp = sqrt(sqr(w[1]) + sqr(w[2]));
				if (wp == 0.0) {
					eprintf("FATAL: Star %ld : wp=0 in perturb_stars_new()\n", si);
					eprintf("FATAL: si=%5ld  r=%.6g  vr=%.6G  vt=%.6g  rp=%.6G  vrp=%.6g  vtp=%.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
					exit_cleanly(1);
				}
				
				w1[1] = w[2] * W / wp;
				w1[2] = -w[1] * W / wp;
				w1[3] = 0.0;
				w2[1] = -w[1] * w[3] / wp;
				w2[2] = -w[2] * w[3] / wp;
				w2[3] = wp;
				
				psi = rng_t113_dbl() * 2 * PI;
				for (j = 1; j <= 3; j++) {
					w_new[j] = w[j] * cos(beta) + w1[j] * sin(beta) * cos(psi) + w2[j] * sin(beta) * sin(psi);
				}
				
				for (j = 1; j <= 3; j++) {
					v_new[j] = v[j] - mp / (m + mp) * (w_new[j] - w[j]);
					vp_new[j] = vp[j] + m / (m + mp) * (w_new[j] - w[j]);
				}
				
				/* New velocities found */ 
				vr_new = v_new[3];
				vt_new = sqrt(v_new[1] * v_new[1] + v_new[2] * v_new[2]);
				vrp_new = vp_new[3];
				vtp_new = sqrt(vp_new[1] * vp_new[1] + vp_new[2] * vp_new[2]);
				
				/* when sin2beta > 1, encounter is repeated until sin2beta <= 1 */
				if (RepeatEncounter) {
					vr = vr_new;	/* assign new velocities for use in repeated encounter */
					vt = vt_new;
					vrp = vrp_new;
					vtp = vtp_new;
				} else {
					/******** Check to see if a STRONG interaction is due for these stars   *******/
					/* save value of beta due to 2-body relaxation */
					/*  beta_relax = beta ;	 */
					/*  local_density = 2*p / (4*PI/3) / (pow(star[si_plus_p].r, 3.0) - */
					/*                                         pow(star[si_minus_p].r, 3.0)); */
					/* number of interactions per unit area */
					/*  lambda = local_density * W * dt; */
					/*****************************************************************************/
					
					/* Calculate new energies by recomputing E = PE + KE using new velocity*/ 
					star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
					star[k].J = r * vt_new;
					star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
					star[kp].J = rp * vtp_new;
					
					/* set new velocities for both stars */
					star[k].vr = vr_new;
					star[k].vt = vt_new;
					star[kp].vr = vrp_new;
					star[kp].vt = vtp_new;
					
					star[k].interacted = 1;
					star[kp].interacted = 1;
				}
			}
		}
	}
}

/* perturb stars that calls Fewbody */
void perturb_stars_fewbody(double dt, gsl_rng *rng)
{
	long si, N_LIMIT, kb;
	double SaveDt, l, madhoc;
	double W=0.0, v[4], vp[4], w[4], phi, psi, beta, wp, w1[4], w2[4];
	double v_new[4], vp_new[4], vr_new, vt_new, vrp_new, vtp_new;
	double r=0.0, rp=0.0, rm, Dr, m=0.0, mp=0.0, w_new[4];
	double DeltaE, DeltaEp, vr=0.0, vt=0.0, vrp=0.0, vtp=0.0, Ai;
	long p = 20, i, sip, k, kp, j, si_minus_p, si_plus_p, RepeatEncounter;
	double min_dist, p_max=0.0, P_enc=0.0, n_local, n_bin_local, del_v, a, b, c, theta;
	double BE, DBE, DBE1, DBE2, DBE3, rpp, vrpp, vtpp, mpp, vrpp_new, vtpp_new;
	double DeltaEpp, DY=0.0, BE1, BE2, vcm[4];
	long bi, bcount, i_nearest, kpp;
	double sin2beta, r_max;
	long interactiondone, nbb=0, nbs=0;
	/* FEWBODY */
	int tid=-1, bid=-1, sid=-1, s1id=-1, s2id=-1;
	unsigned long int seed;
	double m0, m00, m01, m10, m11, r0, r00, r01, r10, r11, a0, a1, e0, e1, vinf, vc, vtrip[3];
	double bs_t, bb_t, wx[4], wy[4], wz[4], vnew[4], vpnew[4], vppnew[4], alpha;
	fb_obj_t threeobjs[3];
	fb_hier_t bs_hier, bb_hier;
	fb_units_t bs_fb_units, bs_sf_units, bb_fb_units, bb_sf_units;
	fb_ret_t bs_retval, bb_retval;
	char string1[1024], string2[1024];
	
	/* set the (N-body) units, written in CGS */
	units_set();

	/* Masses such as star.m and binary.m1 and binary.m2 are not stored in code units, 
	   but rather in code units * clus.N_STAR.  This means that whenever you want to
	   calculate a quantity that involves masses and lengths, or masses and times, you
	   have to divide any masses in the expression by clus.N_STAR.  This is that 
	   factor.  */
	madhoc = 1.0/((double) clus.N_STAR);

	/* useful debugging */
	if (tcount == 1) {
		dprintf("MEGA_YEAR=%g\n", MEGA_YEAR);
		dprintf("SOLAR_MASS_DYN=%g\n", SOLAR_MASS_DYN);
		dprintf("initial_total_mass=%g\n", initial_total_mass);
		dprintf("units.t=%g YEAR\n", units.t/YEAR);
		dprintf("units.m=%g MSUN\n", units.m/MSUN);
		dprintf("units.l=%g PARSEC\n", units.l/PARSEC);
	}

	/* malloc hier */
	bs_hier.nstarinit = 3;
	fb_malloc_hier(&bs_hier);
	
	/* malloc hier */
	bb_hier.nstarinit = 4;
	fb_malloc_hier(&bb_hier);

	SaveDt = dt;		/* Original dt provided, saved for repeated encounters, where dt is changed */
	Delta_BE_bb = 0.0;	/* Total energy generated by binary-binary interactions */
	Delta_BE_bs = 0.0;	/* Total energy generated by binary-single interactions */
	clus.N_MAX_NEW = clus.N_MAX;	/* keeps track of stars from disrupted binaries */

	/* set up the subcount timestep business */
	if (sub.count == 0) {
		N_LIMIT = clus.N_MAX;	/* do FULL time step */
	} else {
		N_LIMIT = sub.N_MAX;	/* do sub step only */
	}

	/******************************/
	/* binary-binary interactions */
	/******************************/
	if (BINBIN) {
		for (si = 1; si <= N_LIMIT; si++) {
			if (si > sub.N_MAX) {	/* part of outer halo in a FULL time step */
				dt = sub.totaltime;
			} else {
				dt = SaveDt;
			}
			
			k = si;
			if (star[k].binind > 0 && star[k].interacted == 0) {
				/* Uninteracted binary -- so check for bin-bin interaction */
				
				/* Compute local number density of binaries -- find nearest 5 binaries
				   (or less), by looking out to the nearest 100 stars. 
				   Also, find nearest UNINTERACTED binary to interact with.
				*/
				bcount = 0;
				si_minus_p = si_plus_p = si;
				i_nearest = si;
				for (i = 1; i <= 100; i++) {
					if (si + i <= N_LIMIT && star[si + i].binind > 0) {
						bcount++;
						si_plus_p = si + i;
						if (i_nearest == si && star[si + i].interacted == 0) {
							i_nearest = si + i;
						}
					}
					if (si - i > 0 && star[si - i].binind > 0) {
						bcount++;
						si_minus_p = si - i;
						if (i_nearest == si && star[si - i].interacted == 0) {
							i_nearest = si - i;
						}
					}
					if (bcount > 10)
						break;	/* stop when 10 nearest binaries are found */
				}
				
				bcount++;	/* To account for the binary at si */
				kp = i_nearest;
				
				if (bcount == 1) {	/* No other binary found nearby - so set density = 0 */
					n_bin_local = 0.0;
					P_enc = 0.0;	/* set collision probability = 0 */
				}
				if (bcount == 2) {	/* only one other nearby binary found */
					n_bin_local = (bcount - 1) * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0)
										       - pow(star[si_minus_p].r, 3.0));
				} else {	/* in computing the density, DON'T count the boundary stars */
					n_bin_local = (bcount - 2) * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0)
										       - pow(star[si_minus_p].r, 3.0));
				}
				
				
				/* check for bin-bin interaction between star si & i_nearest */
				
				if (i_nearest != si && n_bin_local > 0) {
					r = star[k].r;
					rp = star[kp].r;
					rm = (r + rp) / 2.0;
					vr = star[k].vr;
					vt = star[k].vt;
					vrp = star[kp].vr;
					vtp = star[kp].vt;
					Dr = fabs(rp - r);
					m = star[k].m;
					mp = star[kp].m;
					
					/* Compute relative speed W */
					phi = rng_t113_dbl() * 2 * PI;
					v[1] = vt;
					v[2] = 0.0;
					v[3] = vr;
					vp[1] = vtp * cos(phi);
					vp[2] = vtp * sin(phi);
					vp[3] = vrp;
					
					for (j=1; j<=3; j++) w[j] = vp[j] - v[j];
					W = sqrt(w[1] * w[1] + w[2] * w[2] + w[3] * w[3]);
					if (W == 0.0) {
						eprintf("Star %ld : W = 0 in perturb_stars_fewbody() - 1\n", si);
						eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n", si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
						exit_cleanly(1);
					}
					
					if (BINBIN_FEWBODY) {
						/* set some reasonable distance of closest approach */
						min_dist = 2.0 * (binary[star[k].binind].a + binary[star[kp].binind].a);
					} else {
						/* set distance of closest approach for collision based on softer binary */
						if (binary[star[k].binind].a > binary[star[kp].binind].a)
							min_dist = 2.0 * (binary[star[k].binind].a);
						else
							min_dist = 2.0 * (binary[star[kp].binind].a);
					}
					
					/* set maximum impact parameter */
					if (BINBIN_FEWBODY) {
						p_max = min_dist * sqrt(1.0 + 2.0*((m+mp)/((double) clus.N_STAR))/(min_dist*W*W));
					} else {
						/* Spitzer's expression for the cross section */
						p_max = sqrt(15.9 * (0.5*(m+mp)/clus.N_STAR) * min_dist / (W * W));
					}
					
					/* Probability of bin-bin encounter P = PI*p_max^2*W*n*dt */
					P_enc = PI * p_max * p_max * W * dt * (1.0 * clus.N_STAR) / log(GAMMA * clus.N_STAR) * n_bin_local / 1.0;
					if (P_enc > 1.0) {
						wprintf("P_enc = %g >= 1!\n", P_enc);
					}
				}
				
				if (rng_t113_dbl() < P_enc) { /* check if bin-bin interaction is DUE */
					/* DO interaction */
					
					/* print to outfile */
					if (nbb == 0) {
						fprintf(stdout, "perturb_stars_fewbody(): performing binary-binary interaction");
						fprintf(logfile, "perturb_stars_fewbody(): performing binary-binary interaction");
					}
					
					fprintf(stdout, " %ld", nbb);
					fflush(stdout);
					fprintf(logfile, " %ld", nbb);
					
					/* increment local counter */
					nbb++;
					
					/* increment global counter */
					N_bb++;
					
					if (BINBIN_FEWBODY) {
						/* seed RNG so run is reproducible outside of this code */
						seed = rand();
						gsl_rng_set(rng, seed);
						
						/* masses should be in CGS */
						m00 = binary[star[k].binind].m1 * madhoc * units.m;
						m01 = binary[star[k].binind].m2 * madhoc * units.m;
						m10 = binary[star[kp].binind].m1 * madhoc * units.m;
						m11 = binary[star[kp].binind].m2 * madhoc * units.m;
						/* radii and semimajor axes should be in CGS */
						r00 = 0.0;
						r01 = 0.0;
						r10 = 0.0;
						r11 = 0.0;
						a0 = binary[star[k].binind].a * units.l;
						a1 = binary[star[kp].binind].a * units.l;
						e0 = binary[star[k].binind].e;
						e1 = binary[star[kp].binind].e;
						
						/* v_inf should be in units of v_crit */
						vc = sqrt((m+mp)/(m*mp)*(binary[star[k].binind].m1*binary[star[k].binind].m2/binary[star[k].binind].a + binary[star[kp].binind].m1*binary[star[kp].binind].m2/binary[star[kp].binind].a)/((double) clus.N_STAR));
						vinf = W/vc;
						/* b should be in units of a */
						b = sqrt(rng_t113_dbl()) * p_max / (binary[star[k].binind].a + binary[star[kp].binind].a);
						
						/* get the units, relative to local (code) units */
						bb_sf_units.v = sqrt((m+mp)/(m*mp)*(binary[star[k].binind].m1*binary[star[k].binind].m2/binary[star[k].binind].a + binary[star[kp].binind].m1*binary[star[kp].binind].m2/binary[star[kp].binind].a)/((double) clus.N_STAR));
						bb_sf_units.l = binary[star[k].binind].a + binary[star[kp].binind].a;
						bb_sf_units.t = bb_sf_units.l / bb_sf_units.v;
						bb_sf_units.m = bb_sf_units.l * sqr(bb_sf_units.v);
						bb_sf_units.E = bb_sf_units.m * sqr(bb_sf_units.v);
						
						/* print to binbin file */
						gzprintf(binbinfile, "***** id=%ld\n", N_bb);
						gzprintf(binbinfile, "./binbin --m00 %.9g --m01 %.9g --m10 %.9g --m11 %.9g --r00 %.9g --r01 %.9g --r10 %.9g --r11 %.9g --a0 %.9g --a1 %.9g --e0 %.9g --e1 %.9g --vinf %.9g --b %.9g --seed %ld\n", \
							 m00/FB_CONST_MSUN, m01/FB_CONST_MSUN, m10/FB_CONST_MSUN, m11/FB_CONST_MSUN,
							 r00/FB_CONST_RSUN, r01/FB_CONST_RSUN, r10/FB_CONST_RSUN, r11/FB_CONST_RSUN,
							 a0/FB_CONST_AU, a1/FB_CONST_AU, e0, e1, vinf, b, seed);
						gzprintf(binbinfile, "init:\tm00=%.6g m01=%.6g m10=%.6g m11=%.6g\n", 
							 m00/FB_CONST_MSUN, m01/FB_CONST_MSUN, m10/FB_CONST_MSUN, m11/FB_CONST_MSUN);
						gzprintf(binbinfile, "init:\tR00=%.6g R01=%.6g R10=%.6g R11=%.6g\n", 
							 r00/FB_CONST_RSUN, r01/FB_CONST_RSUN, r10/FB_CONST_RSUN, r11/FB_CONST_RSUN);
						gzprintf(binbinfile, "init:\ta0=%.6g a1=%.6g e0=%.6g e1=%.6g\n", 
							 a0/FB_CONST_AU, a1/FB_CONST_AU, e0, e1);
						gzprintf(binbinfile, "init:\tvinf=%.6g b=%.6g bmax=%.6g\n", 
							 vinf, b, p_max / (binary[star[k].binind].a + binary[star[kp].binind].a));

						/* call fewbody! */
						bb_retval = binbin(&bb_t, m00, m01, m10, m11, r00, r01, r10, r11, a0, a1, e0, e1, vinf, b, &bb_fb_units, &bb_hier, rng);
						/* print to binbin file */
						gzprintf(binbinfile, "final:\tretval=%d nstar=%d nobj=%d t=%.6g tcpu=%.6g\n", 
							 bb_retval.retval, bb_hier.nstar, bb_hier.nobj, bb_t, bb_retval.tcpu);
						gzprintf(binbinfile, "final:\tDL=%.6g DL/Li=%.6g DE=%.6g DE/Ei=%.6g\n", 
							 bb_retval.DeltaL, bb_retval.DeltaLfrac, bb_retval.DeltaE, bb_retval.DeltaEfrac);
						gzprintf(binbinfile, "final:\tencounter %scomplete: %s (%s)\n",
							 bb_retval.retval==0?"NOT ":"", fb_sprint_hier(bb_hier, string1), fb_sprint_hier_hr(bb_hier, string2));
						
						/* set up axes */
						wp = sqrt(sqr(w[1]) + sqr(w[2]));
						if (wp == 0.0) {
							eprintf("FATAL: Star %ld : wp = 0 in perturb_stars_fewbody()\n", si);
							eprintf("FATAL: si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n", 
								si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
							exit_cleanly(1);
						}
						
						/* wx, wy, and wz are the x, y, and z axes (unit vectors) of the fewbody
						   coordinate system represented in the cluster frame */
						wx[0] = 1.0;
						wx[1] = w[1]/W;
						wx[2] = w[2]/W;
						wx[3] = w[3]/W;
						wy[0] = 1.0;
						wy[1] = -w[1] * w[3] / (wp * W);
						wy[2] = -w[2] * w[3] / (wp * W);
						wy[3] = wp / W;
						wz[0] = 1.0;
						wz[1] = w[2] / wp;
						wz[2] = -w[1] / wp;
						wz[3] = 0.0;
						
						/* this will be used later */
						for (j=1; j<=3; j++) vcm[j] = (m * v[j] + mp * vp[j])/(m + mp);
						
						/* alpha is the factor by which to scale the velocities, as an artificial
						   way of bringing the objects to infinity while conserving energy and angular momentum */
						alpha = sqrt(1.0 + fb_outerpetot(bb_hier.obj, bb_hier.nobj)/fb_outerketot(bb_hier.obj, bb_hier.nobj));
						
						/* binding energies */
						BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 * sqr(madhoc) / (2.0 * binary[star[k].binind].a);
						BE2 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 * sqr(madhoc) / (2.0 * binary[star[kp].binind].a);
						BE = BE1 + BE2;
						
						/**************************************************************/
						/*** deal with binary-binary outcomes ***/
						/**************************************************************/
						if (fabs(bb_retval.DeltaEfrac) > 0.01) {
							/* energy error; ignore for now */
							gzprintf(binbinfile, "final:\toutcome=energy error\n");
							fprintf(stdout, "!");
							fprintf(logfile, "!");
							gzprintf(binbinfile, "ERROR: Don't know how to deal with Fewbody outcome \"energy error\".\n");
						} else if (bb_retval.retval == 0) {
							/* t > tstop or tcpu > tcpustop */
							gzprintf(binbinfile, "final:\toutcome=stopped\n");
							/* ignore this outcome for now */
							fprintf(stdout, "!");
							fprintf(logfile, "!");
							gzprintf(binbinfile, "ERROR: Don't know how to deal with Fewbody outcome \"stopped\".\n");
						} else {
							/* binary-binary interaction completed successfully */
							if (bb_hier.nstar == 4) {
								if (bb_hier.nobj == 1) {
									/**************************************************************/
									/*** quadruple ***/
									/**************************************************************/
									gzprintf(binbinfile, "final:\toutcome=quadruple\n");
									/* break up quad; this outcome is very unlikely; ignore for now */
									fprintf(stdout, "!");
									fprintf(logfile, "!");
									gzprintf(binbinfile, "ERROR: Don't know how to deal with Fewbody outcome \"quadruple\".\n");
								} else if (bb_hier.nobj == 2) {
									/**************************************************************/
									/*** binary-binary or triple-single ***/
									/**************************************************************/
									if ((fb_n_hier(bb_hier.obj[0]) == 2)&&(fb_n_hier(bb_hier.obj[1]) == 2)) {
										/**************************************************************/
										/*** binary-binary ***/
										/**************************************************************/
										if ((bb_hier.obj[0]->obj[0]->id[0]==0 && bb_hier.obj[0]->obj[1]->id[0]==1)||
										    (bb_hier.obj[0]->obj[0]->id[0]==1 && bb_hier.obj[0]->obj[1]->id[0]==0)) {
											/**************************************************************/
											/*** preservation ***/
											/**************************************************************/
											gzprintf(binbinfile, "final:\toutcome=preservation\n");
											/* set new binary props, keeping binaries at same radii in cluster */
											binary[star[k].binind].a = bb_hier.obj[0]->a * bb_sf_units.l;
											binary[star[k].binind].e = bb_hier.obj[0]->e;
											binary[star[kp].binind].a = bb_hier.obj[1]->a * bb_sf_units.l;
											binary[star[kp].binind].e = bb_hier.obj[1]->e;
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[0]->v[0] * wx[j] + bb_hier.obj[0]->v[1] * wy[j] + bb_hier.obj[0]->v[2] * wz[j]);
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[1]->v[0] * wx[j] + bb_hier.obj[1]->v[1] * wy[j] + bb_hier.obj[1]->v[2] * wz[j]);
											}
										} else if ((bb_hier.obj[1]->obj[0]->id[0]==0 && bb_hier.obj[1]->obj[1]->id[0]==1)||
											   (bb_hier.obj[1]->obj[0]->id[0]==1 && bb_hier.obj[1]->obj[1]->id[0]==0)) {
											/**************************************************************/
											/*** preservation ***/
											/**************************************************************/
											gzprintf(binbinfile, "final:\toutcome=preservation\n");
											/* set new binary props, keeping binaries at same radii in cluster */
											binary[star[k].binind].a = bb_hier.obj[1]->a * bb_sf_units.l;
											binary[star[k].binind].e = bb_hier.obj[1]->e;
											binary[star[kp].binind].a = bb_hier.obj[0]->a * bb_sf_units.l;
											binary[star[kp].binind].e = bb_hier.obj[0]->e;
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[1]->v[0] * wx[j] + bb_hier.obj[1]->v[1] * wy[j] + bb_hier.obj[1]->v[2] * wz[j]);
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[0]->v[0] * wx[j] + bb_hier.obj[0]->v[1] * wy[j] + bb_hier.obj[0]->v[2] * wz[j]);
											}
										} else {
											/**************************************************************/
											/*** exchange ***/
											/**************************************************************/
											gzprintf(binbinfile, "final:\toutcome=exchange\n");
											/* set new binary props, keeping binaries at same radii in cluster */
											binary[star[k].binind].a = bb_hier.obj[0]->a * bb_sf_units.l;
											binary[star[k].binind].e = bb_hier.obj[0]->e;
											binary[star[k].binind].m1 = bb_hier.obj[0]->obj[0]->m * bb_sf_units.m / madhoc;
											binary[star[k].binind].m2 = bb_hier.obj[0]->obj[1]->m * bb_sf_units.m / madhoc;
											binary[star[kp].binind].a = bb_hier.obj[1]->a * bb_sf_units.l;
											binary[star[kp].binind].e = bb_hier.obj[1]->e;
											binary[star[kp].binind].m1 = bb_hier.obj[1]->obj[0]->m * bb_sf_units.m / madhoc;
											binary[star[kp].binind].m2 = bb_hier.obj[1]->obj[1]->m * bb_sf_units.m / madhoc;
											
											/* update new binaries' masses */
											star[k].m = binary[star[k].binind].m1 + binary[star[k].binind].m2;
											star[kp].m = binary[star[kp].binind].m1 + binary[star[kp].binind].m2;
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[1]->v[0] * wx[j] + bb_hier.obj[1]->v[1] * wy[j]+ bb_hier.obj[1]->v[2] * wz[j]);
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[0]->v[0] * wx[j] + bb_hier.obj[0]->v[1] * wy[j]+ bb_hier.obj[0]->v[2] * wz[j]);
											}
										}
										
										/* print some info */
										gzprintf(binbinfile, "final:\ta0=%.6g a1=%.6g e0=%.6g e1=%.6g\n", 
											 binary[star[k].binind].a * units.l / FB_CONST_AU,
											 binary[star[kp].binind].a * units.l / FB_CONST_AU,
											 binary[star[k].binind].e, binary[star[kp].binind].e);
										gzprintf(binbinfile, "final:\tm00=%.6g m01=%.6g m10=%.6g m11=%.6g\n", 
											 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[kp].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[kp].binind].m2 * madhoc * units.m / FB_CONST_MSUN);
										
										/* update binding energy information */
										BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
											sqr(madhoc) / (2.0 * binary[star[k].binind].a);
										BE2 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 *
											sqr(madhoc) / (2.0 * binary[star[kp].binind].a);
										DBE = BE1 + BE2 - BE;
										Delta_BE_bb += DBE;	/* total bin-bin energy generated in the timestep */
										DE_bb += DBE;	/* ongoing total bin-bin energy generated */
										
										/* set binaries' global properties */
										vr_new = vnew[3];
										vt_new = sqrt(sqr(vnew[1]) + sqr(vnew[2]));
										vrp_new = vpnew[3];
										vtp_new = sqrt(sqr(vpnew[1]) + sqr(vpnew[2]));
										
										/* calculate new energies */
										DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
										DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
										
										star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
										star[k].J = r * vt_new;
										star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
										star[kp].J = rp * vtp_new;
										
										star[k].vr = vr_new;
										star[k].vt = vt_new;
										star[kp].vr = vrp_new;
										star[kp].vt = vtp_new;
										
										/* Binary-binary interaction done; does "3" mean binary-binary interaction? */
										star[k].interacted = star[kp].interacted = 3;
									} else if (((fb_n_hier(bb_hier.obj[0]) == 3)&&(fb_n_hier(bb_hier.obj[1]) == 1))||
										   ((fb_n_hier(bb_hier.obj[0]) == 1)&&(fb_n_hier(bb_hier.obj[1]) == 3))) {
										/**************************************************************/
										/*** triple-single ***/
										/**************************************************************/
										gzprintf(binbinfile, "final:\toutcome=triple-single\n");
										
										/* find triple */
										if (fb_n_hier(bb_hier.obj[0])==3) {
											tid = 0;
											sid = 1;
										} else {
											tid = 1;
											sid = 0;
										}
										
										/* find inner binary of triple */
										if (fb_n_hier(bb_hier.obj[tid]->obj[0])==2) {
											bid = 0;
											s1id = 1;
										} else {
											bid = 1;
											s1id = 0;
										}
										
										/* put triple at origin */
										bb_hier.obj[tid]->x[0] = 0.0;
										bb_hier.obj[tid]->x[1] = 0.0;
										bb_hier.obj[tid]->x[2] = 0.0;
										
										/* store triple's velocity */
										vtrip[0] = bb_hier.obj[tid]->v[0];
										vtrip[1] = bb_hier.obj[tid]->v[1];
										vtrip[2] = bb_hier.obj[tid]->v[2];
										
										/* and set triple to zero velocity */
										bb_hier.obj[tid]->v[0] = 0.0;
										bb_hier.obj[tid]->v[1] = 0.0;
										bb_hier.obj[tid]->v[2] = 0.0;
										
										/* trickle down properties */
										fb_downsync(bb_hier.obj[tid], bb_t);
										fb_downsync(bb_hier.obj[tid]->obj[bid], bb_t);
										
										/* temporarily store triple's stars' information so that 
										   we can calculate the triple's energy */
										threeobjs[0] = *(bb_hier.obj[tid]->obj[s1id]);
										threeobjs[1] = *(bb_hier.obj[tid]->obj[bid]->obj[0]);
										threeobjs[2] = *(bb_hier.obj[tid]->obj[bid]->obj[1]);
										
										/* bring outer member of triple to zero energy, decreasing inner binary's semimajor axis
										   in the process, but preserving its eccentricity */
										bb_hier.obj[tid]->obj[bid]->a = -(bb_hier.obj[tid]->obj[bid]->obj[0]->m)*(bb_hier.obj[tid]->obj[bid]->obj[1]->m)/
											(2.0 * (fb_ketot(threeobjs, 3) + fb_petot(threeobjs, 3)));
										
										/* print some info */
										gzprintf(binbinfile, "final:\ta=%.6g e=%.6g\n", 
											 bb_hier.obj[tid]->obj[bid]->a * bb_sf_units.l * units.l / FB_CONST_AU,
											 bb_hier.obj[tid]->obj[bid]->e);
										
										/* check for preserved binary */
										if ((bb_hier.obj[tid]->obj[bid]->obj[0]->id[0]==0 && bb_hier.obj[tid]->obj[bid]->obj[1]->id[0]==1)||
										    (bb_hier.obj[tid]->obj[bid]->obj[0]->id[0]==1 && bb_hier.obj[tid]->obj[bid]->obj[1]->id[0]==0)) {
											/* unprimed binary is preserved */
											binary[star[k].binind].a = bb_hier.obj[tid]->obj[bid]->a * bb_sf_units.l;
											binary[star[k].binind].e = bb_hier.obj[tid]->obj[bid]->e;
											
											BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
												sqr(madhoc) / (2.0 * binary[star[k].binind].a);
											
											/* destroy other binary */
											kpp = destroy_binary(kp);
											
											/* assign other stars */
											mp = star[kp].m = bb_hier.obj[sid]->m * bb_sf_units.m / madhoc;
											mpp = star[kpp].m = bb_hier.obj[tid]->obj[s1id]->m * bb_sf_units.m / madhoc;
											rpp = star[kp].r;
											star[kpp].r = rpp;
											star[kpp].phi = star[kp].phi;
											vrpp = star[kp].vr;
											vtpp = star[kp].vt;
											
											/* print a little something to the binbinlog file */
											gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
												 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
												 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
												 star[kp].m * madhoc * units.m / FB_CONST_MSUN,
												 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j] + vtrip[2] * wz[j]);
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[sid]->v[0] * wx[j] + bb_hier.obj[sid]->v[1] * wy[j] + bb_hier.obj[sid]->v[2] * wz[j]);
												vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j] + vtrip[2] * wz[j]);
											}
										} else if ((bb_hier.obj[tid]->obj[bid]->obj[0]->id[0]==2 && bb_hier.obj[tid]->obj[bid]->obj[1]->id[0]==3)||
											   (bb_hier.obj[tid]->obj[bid]->obj[0]->id[0]==3 && bb_hier.obj[tid]->obj[bid]->obj[1]->id[0]==2)) {
											/* primed binary is preserved */
											binary[star[kp].binind].a = bb_hier.obj[tid]->obj[bid]->a * bb_sf_units.l;
											binary[star[kp].binind].e = bb_hier.obj[tid]->obj[bid]->e;
											
											BE1 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 *
												sqr(madhoc) / (2.0 * binary[star[kp].binind].a);
											
											/* destroy other binary */
											kpp = destroy_binary(k);
											
											/* assign other stars */
											m = star[k].m = bb_hier.obj[sid]->m * bb_sf_units.m / madhoc;
											mpp = star[kpp].m = bb_hier.obj[tid]->obj[s1id]->m * bb_sf_units.m / madhoc;
											rpp = star[k].r;
											star[kpp].r = rpp;
											star[kpp].phi = star[k].phi;
											vrpp = star[k].vr;
											vtpp = star[k].vt;
											
											/* print a little something to the binbinlog file */
											gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
												 binary[star[kp].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
												 binary[star[kp].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
												 star[k].m * madhoc * units.m / FB_CONST_MSUN,
												 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j] + vtrip[2] * wz[j]);
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[sid]->v[0] * wx[j] + bb_hier.obj[sid]->v[1] * wy[j] + bb_hier.obj[sid]->v[2] * wz[j]);
												vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j] + vtrip[2] * wz[j]);
											}
										} else {
											/* neither binary is preserved, so just assign binary to index k */
											binary[star[k].binind].a = bb_hier.obj[tid]->obj[bid]->a * bb_sf_units.l;
											binary[star[k].binind].e = bb_hier.obj[tid]->obj[bid]->e;
											binary[star[k].binind].m1 = bb_hier.obj[tid]->obj[bid]->obj[0]->m * bb_sf_units.m / madhoc;
											binary[star[k].binind].m2 = bb_hier.obj[tid]->obj[bid]->obj[1]->m * bb_sf_units.m / madhoc;
											
											/* update binary's mass */
											star[k].m = binary[star[k].binind].m1 + binary[star[k].binind].m2;
											
											BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
												sqr(madhoc) / (2.0 * binary[star[k].binind].a);
											
											/* destroy other binary */
											kpp = destroy_binary(kp);
											
											/* assign other stars */
											mp = star[kp].m = bb_hier.obj[sid]->m * bb_sf_units.m / madhoc;
											mpp = star[kpp].m = bb_hier.obj[tid]->obj[s1id]->m * bb_sf_units.m / madhoc;
											rpp = star[kp].r;
											star[kpp].r = rpp;
											star[kpp].phi = star[kp].phi;
											vrpp = star[kp].vr;
											vtpp = star[kp].vt;
											
											/* print a little something to the binbinlog file */
											gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
												 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
												 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
												 star[kp].m * madhoc * units.m / FB_CONST_MSUN,
												 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
											
											/* figure out new velocities */
											for (j=1; j<=3; j++) {
												vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j] + vtrip[2] * wz[j]);
												vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(bb_hier.obj[sid]->v[0] * wx[j] + bb_hier.obj[sid]->v[1] * wy[j]+ bb_hier.obj[sid]->v[2] * wz[j]);
												vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
													(vtrip[0] * wx[j] + vtrip[1] * wy[j]+ vtrip[2] * wz[j]);
											}
										}
										
										DBE = BE1 - BE;
										Delta_BE_bb += DBE;	/* total bin-bin energy generated in the timestep */
										DE_bb += DBE;	/* ongoing total bin-bin energy generated */
										
										/* set binary's global properties */
										vr_new = vnew[3];
										vt_new = sqrt(sqr(vnew[1]) + sqr(vnew[2]));
										vrp_new = vpnew[3];
										vtp_new = sqrt(sqr(vpnew[1]) + sqr(vpnew[2]));
										vrpp_new = vppnew[3];
										vtpp_new = sqrt(sqr(vppnew[1]) + sqr(vppnew[2]));
										
										/* recompute energies of binary and star */
										DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
										DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
										DeltaEpp = 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new - vrpp * vrpp - vtpp * vtpp);
										
										/* Calculate new energies by recomputing E = PE + KE using new velocity */
										star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
										star[k].J = r * vt_new;
										star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
										star[kp].J = rp * vtp_new;
										/* star[].phi is not yet computed for kpp, so use position of kp, already set in star[kpp].phi */
										star[kpp].E = star[kpp].phi + 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new);
										star[kpp].J = rpp * vtpp_new;
										
										/* set new velocities for both stars */
										star[k].vr = vr_new;
										star[k].vt = vt_new;
										star[kp].vr = vrp_new;
										star[kp].vt = vtp_new;
										star[kpp].vr = vrpp_new;
										star[kpp].vt = vtpp_new;
										
										/* now set the potential at new particle's position to zero */
										star[kpp].phi = 0.0;
										
										/* Binary-binary interaction done; does "3" mean binary-binary interaction? */
										star[k].interacted = star[kp].interacted = star[kpp].interacted = 3;
									} else {
										/* who knows what went wrong */
										eprintf("Corrupt fewbody outcome.\n");
										exit_cleanly(1);
									}
								} else if (bb_hier.nobj == 3) {
									/**************************************************************/
									/*** single ionization ***/
									/**************************************************************/
									gzprintf(binbinfile, "final:\toutcome=ionization\n");
									if ((fb_n_hier(bb_hier.obj[0])==2)&&(fb_n_hier(bb_hier.obj[1])==1)&&(fb_n_hier(bb_hier.obj[2])==1)) {
										bid = 0;
										s1id = 1;
										s2id = 2;
									} else if ((fb_n_hier(bb_hier.obj[0])==1)&&(fb_n_hier(bb_hier.obj[1])==2)&&(fb_n_hier(bb_hier.obj[2])==1)) {
										s1id = 0;
										bid = 1;
										s2id = 2;
									} else if ((fb_n_hier(bb_hier.obj[0])==1)&&(fb_n_hier(bb_hier.obj[1])==1)&&(fb_n_hier(bb_hier.obj[2])==2)) {
										s1id = 0;
										s2id = 1;
										bid = 2;
									} else {
										/* who knows what went wrong */
										eprintf("Corrupt fewbody outcome.\n");
										exit_cleanly(1);
									}
									
									/* print some info */
									gzprintf(binbinfile, "final:\ta=%.6g e=%.6g\n", 
										 bb_hier.obj[bid]->a * bb_sf_units.l * units.l / FB_CONST_AU,
										 bb_hier.obj[bid]->e);
									
									/* check for preserved binary */
									if ((bb_hier.obj[bid]->obj[0]->id[0]==0 && bb_hier.obj[bid]->obj[1]->id[0]==1)||
									    (bb_hier.obj[bid]->obj[0]->id[0]==1 && bb_hier.obj[bid]->obj[1]->id[0]==0)) {
										/**************************************************************/
										/*** unprimed binary is preserved ***/
										/**************************************************************/
										binary[star[k].binind].a = bb_hier.obj[bid]->a * bb_sf_units.l;
										binary[star[k].binind].e = bb_hier.obj[bid]->e;
										
										BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
											sqr(madhoc) / (2.0 * binary[star[k].binind].a);
										
										/* destroy other binary */
										kpp = destroy_binary(kp);
										
										/* assign other stars */
										mp = star[kp].m = bb_hier.obj[s1id]->m * bb_sf_units.m / madhoc;
										mpp = star[kpp].m = bb_hier.obj[s2id]->m * bb_sf_units.m / madhoc;
										rpp = star[kp].r;
										star[kpp].r = rpp;
										star[kpp].phi = star[kp].phi;
										vrpp = star[kp].vr;
										vtpp = star[kp].vt;
										
										/* print a little something to the binbinlog file */
										gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
											 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
											 star[kp].m * madhoc * units.m / FB_CONST_MSUN,
											 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
										
										/* figure out new velocities */
										for (j=1; j<=3; j++) {
											vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[bid]->v[0] * wx[j] + bb_hier.obj[bid]->v[1] * wy[j]+ bb_hier.obj[bid]->v[2] * wz[j]);
											vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s1id]->v[0] * wx[j] + bb_hier.obj[s1id]->v[1] * wy[j]+ bb_hier.obj[s1id]->v[2] * wz[j]);
											vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s2id]->v[0] * wx[j] + bb_hier.obj[s2id]->v[1] * wy[j]+ bb_hier.obj[s2id]->v[2] * wz[j]);
										}
									} else if ((bb_hier.obj[bid]->obj[0]->id[0]==2 && bb_hier.obj[bid]->obj[1]->id[0]==3)||
										   (bb_hier.obj[bid]->obj[0]->id[0]==3 && bb_hier.obj[bid]->obj[1]->id[0]==2)) {
										/**************************************************************/
										/*** primed binary is preserved ***/
										/**************************************************************/
										binary[star[kp].binind].a = bb_hier.obj[bid]->a * bb_sf_units.l;
										binary[star[kp].binind].e = bb_hier.obj[bid]->e;
										
										BE1 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 *
											sqr(madhoc) / (2.0 * binary[star[kp].binind].a);
										
										/* destroy other binary */
										kpp = destroy_binary(k);
										
										/* assign other stars */
										m = star[k].m = bb_hier.obj[s1id]->m * bb_sf_units.m / madhoc;
										mpp = star[kpp].m = bb_hier.obj[s2id]->m * bb_sf_units.m / madhoc;
										rpp = star[k].r;
										star[kpp].r = rpp;
										star[kpp].phi = star[k].phi;
										vrpp = star[k].vr;
										vtpp = star[k].vt;
										
										/* print a little something to the binbinlog file */
										gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
											 binary[star[kp].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[kp].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
											 star[k].m * madhoc * units.m / FB_CONST_MSUN,
											 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
										
										/* figure out new velocities */
										for (j=1; j<=3; j++) {
											vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[bid]->v[0] * wx[j] + bb_hier.obj[bid]->v[1] * wy[j]+ bb_hier.obj[bid]->v[2] * wz[j]);
											vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s1id]->v[0] * wx[j] + bb_hier.obj[s1id]->v[1] * wy[j]+ bb_hier.obj[s1id]->v[2] * wz[j]);
											vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s2id]->v[0] * wx[j] + bb_hier.obj[s2id]->v[1] * wy[j]+ bb_hier.obj[s2id]->v[2] * wz[j]);
										}
									} else {
										/**************************************************************/
										/*** neither binary is preserved, so just assign binary to index k ***/
										/**************************************************************/
										binary[star[k].binind].a = bb_hier.obj[bid]->a * bb_sf_units.l;
										binary[star[k].binind].e = bb_hier.obj[bid]->e;
										binary[star[k].binind].m1 = bb_hier.obj[bid]->obj[0]->m * bb_sf_units.m / madhoc;
										binary[star[k].binind].m2 = bb_hier.obj[bid]->obj[1]->m * bb_sf_units.m / madhoc;
										
										/* update binary's mass */
										star[k].m = binary[star[k].binind].m1 + binary[star[k].binind].m2;
										
										BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
											sqr(madhoc) / (2.0 * binary[star[k].binind].a);
										
										/* destroy other binary */
										kpp = destroy_binary(kp);
										
										/* assign other stars */
										mp = star[kp].m = bb_hier.obj[s1id]->m * bb_sf_units.m / madhoc;
										mpp = star[kpp].m = bb_hier.obj[s2id]->m * bb_sf_units.m / madhoc;
										rpp = star[kp].r;
										star[kpp].r = rpp;
										star[kpp].phi = star[kp].phi;
										vrpp = star[kp].vr;
										vtpp = star[kp].vt;
										
										/* print a little something to the binbinlog file */
										gzprintf(binbinfile, "final:\tm0=%.6g m1=%.6g m2=%.6g m3=%.6g\n", 
											 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
											 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
											 star[kp].m * madhoc * units.m / FB_CONST_MSUN,
											 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
										
										/* figure out new velocities */
										for (j=1; j<=3; j++) {
											vnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[bid]->v[0] * wx[j] + bb_hier.obj[bid]->v[1] * wy[j]+ bb_hier.obj[bid]->v[2] * wz[j]);
											vpnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s1id]->v[0] * wx[j] + bb_hier.obj[s1id]->v[1] * wy[j]+ bb_hier.obj[s1id]->v[2] * wz[j]);
											vppnew[j] = vcm[j] + bb_sf_units.v * alpha * 
												(bb_hier.obj[s2id]->v[0] * wx[j] + bb_hier.obj[s2id]->v[1] * wy[j]+ bb_hier.obj[s2id]->v[2] * wz[j]);
										}
									}
									
									DBE = BE1 - BE;
									Delta_BE_bb += DBE;	/* total bin-bin energy generated in the timestep */
									DE_bb += DBE;	/* ongoing total bin-bin energy generated */
									
									/* set binary's global properties */
									vr_new = vnew[3];
									vt_new = sqrt(sqr(vnew[1]) + sqr(vnew[2]));
									vrp_new = vpnew[3];
									vtp_new = sqrt(sqr(vpnew[1]) + sqr(vpnew[2]));
									vrpp_new = vppnew[3];
									vtpp_new = sqrt(sqr(vppnew[1]) + sqr(vppnew[2]));
									
									/* recompute energies of binary and star */
									DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
									DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
									DeltaEpp = 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new - vrpp * vrpp - vtpp * vtpp);
									
									/* Calculate new energies by recomputing E = PE + KE using new velocity */
									star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
									star[k].J = r * vt_new;
									star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
									star[kp].J = rp * vtp_new;
									/* star[].phi is not yet computed for kpp, so use position of kp, already set in star[kpp].phi */
									star[kpp].E = star[kpp].phi + 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new);
									star[kpp].J = rpp * vtpp_new;
									
									/* set new velocities for both stars */
									star[k].vr = vr_new;
									star[k].vt = vt_new;
									star[kp].vr = vrp_new;
									star[kp].vt = vtp_new;
									star[kpp].vr = vrpp_new;
									star[kpp].vt = vtpp_new;
									
									/* now set the potential at new particle's position to zero */
									star[kpp].phi = 0.0;
									
									/* Binary-binary interaction done; does "3" mean binary-binary interaction? */
									star[k].interacted = star[kp].interacted = star[kpp].interacted = 3;
								} else if (bb_hier.nobj == 4) {
									/**************************************************************/
									/*** full ionization ***/
									/**************************************************************/
									gzprintf(binbinfile, "final:\toutcome=full ionization\n");
									/* ignore this outcome for now */
									fprintf(stdout, "!");
									fprintf(logfile, "!");
									gzprintf(binbinfile, "ERROR: Don't know how to deal with fewbody outcome \"full ionization\".\n");
								} else {
									/**************************************************************/
									/*** corrupt fewbody outcome ***/
									/**************************************************************/
									eprintf("Corrupt fewbody outcome.\n");
									exit_cleanly(1);
								}
							} else {
								/* merger; ignore for now */
								gzprintf(binbinfile, "final:\toutcome=merger\n");
								fprintf(stdout, "!");
								fprintf(logfile, "!");
								gzprintf(binbinfile, "ERROR: Don't know how to deal with Fewbody outcome \"merger\".\n");
							}
						}
					} else {
						/* simple recipes */
						/* Compute energy generated from binary -- Delta BE  */
						BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
							sqr(madhoc) / 2.0 / binary[star[k].binind].a;
						BE2 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 *
							sqr(madhoc) / 2.0 / binary[star[kp].binind].a;
						BE = BE1 + BE2;
						
						for (j = 1; j <= N_TRY; j++) {
							DY = rng_t113_dbl() * 1.0;
							if (rng_t113_dbl() * 1.9 < 12.25 * DY / pow((1.0 + 3.5 * DY * DY), 2.75))
								break;
						}
						if (j == N_TRY + 1) {
							eprintf("N_TRY exceeded in bin-bin cross section\n");
							exit_cleanly(1);
						}
						DBE = DY * BE;
						DBE1 = DBE / 4.0;	/* recoil energy of binary */
						DBE2 = (DBE - DBE1) * rng_t113_dbl();	/* recoil energy of first star */
						DBE3 = DBE - DBE1 - DBE2;	/* recoil energy of second star */
						
						/* check which binary is harder */
						if (BE1 < BE2) {	/* binary kp is harder than k */
							bi = k;
							k = kp;
							kp = bi;	/* so interchange binary k & kp */
							BE = BE1;
							BE1 = BE2;
							BE2 = BE;
							BE = BE1 + BE2;
							r = star[k].r;
							rp = star[kp].r;
							rm = (r + rp) / 2.0;
							vr = star[k].vr;
							vt = star[k].vt;
							vrp = star[kp].vr;
							vtp = star[kp].vt;
							Dr = fabs(rp - r);
							m = star[k].m;
							mp = star[kp].m;
						}

						/* Set new (smaller) semi-major axis for binary k (harder binary) 
						   New BE = original(BE1+BE2)+DBE = 2*DBE + DBE = 3*DBE 
						*/
						binary[star[k].binind].a = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
							sqr(madhoc) / 2.0 / (BE1 + BE2 + DBE);
						
						/* binding energy of soft binary is lost since it is destroyed.
						   But it is compensated by harder binary getting harder. So total BE
						   does not decrease due to the destruction of the binary. In addition,
						   more translational energy 0.5*(BE1+BE2) is released by the harder binary.
						*/
						Delta_BE_bb += DBE;	/* total bin-bin energy generated in the timestep */
						DE_bb += DBE;	/* ongoing total bin-bin energy generated */
						
						mp = star[kp].m = binary[star[kp].binind].m1; /* keep first star of the binary as single */
						
						kpp = destroy_binary(kp);
						
						star[kpp].vr = star[kp].vr;
						star[kpp].vt = star[kp].vt;
						
						rpp = star[kp].r;
						vrpp = star[kpp].vr;
						vtpp = star[kpp].vt;
						mpp = star[kpp].m;
						
						star[kpp].r = rpp;

						/*********** compute recoil velocities - binary-binary int **********/
						theta = acos(rng_t113_dbl() * 2.0 - 1.0);
						phi = 2 * PI * rng_t113_dbl();
						
						/* recoil of the binary */
						a = 1;
						b = 2 * (vr * cos(theta) + vt * sin(theta) * cos(phi));
						c = -2 * DBE1 / m * clus.N_STAR;
						del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;
						
						vr_new = vr + del_v * cos(theta);
						vt_new = sqrt(pow(vt + del_v * sin(theta) * cos(phi), 2.0) +
							      pow(del_v * sin(theta) * sin(phi), 2.0));
						
						/* recoil of the star */
						a = 1;
						b = 2 * (vrp * cos(theta) + vtp * sin(theta) * cos(phi));
						c = -2 * DBE2 / mp * clus.N_STAR;
						del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;
						
						vrp_new = vrp + del_v * cos(theta);
						vtp_new = sqrt(pow(vtp + del_v * sin(theta) * cos(phi), 2.0) +
							       pow(del_v * sin(theta) * sin(phi), 2.0));
						
						/* recoil of the second star */
						a = 1;
						b = 2 * (vrpp * cos(theta) + vtpp * sin(theta) * cos(phi));
						c = -2 * DBE3 / mpp * clus.N_STAR;
						del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;
						
						vrpp_new = vrpp + del_v * cos(theta);
						vtpp_new = sqrt(pow(vtpp + del_v * sin(theta) * cos(phi), 2.0) +
								pow(del_v * sin(theta) * sin(phi), 2.0));
						
						/* recompute energies of binary and star */
						DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
						DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
						DeltaEpp = 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new - vrpp * vrpp - vtpp * vtpp);
						
						/* Calculate new energies by recomputing E = PE + KE using new velocity */
						star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
						star[k].J = r * vt_new;
						star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
						star[kp].J = rp * vtp_new;
						/* star[].phi is not yet computed for kpp, so use position of kp */
						star[kpp].E = star[kp].phi + 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new);
						star[kpp].J = rpp * vtpp_new;
						
						/* set new velocities for both stars */
						star[k].vr = vr_new;
						star[k].vt = vt_new;
						star[kp].vr = vrp_new;
						star[kp].vt = vtp_new;
						star[kpp].vr = vrpp_new;
						star[kpp].vt = vtpp_new;
						
						/* binary-binary interaction DONE */
						star[k].interacted = star[kp].interacted = star[kpp].interacted = 3;
					}
				} else {
					/* NO binary-binary interaction due... so label binaries uninteracted.
					   It is possible for k==kp if i_nearest = si, i.e., no nearby bin was found. */
					
					/* I'm pretty sure this line of code is redundant - JMF */
					star[k].interacted = star[kp].interacted = 0;
				}
			} /* End IF (uninteracted binary) */
		} /* End For loop (over all stars to look for uninteracted binaries) */
		
		/* print newline */
		if (nbb) {
			fprintf(stdout, "\n");
			fflush(stdout);
			fprintf(logfile, "\n");
		}
	}
	
	/******************************/
	/* binary-single interactions */
	/******************************/
	for (si = 1; si <= N_LIMIT; si += 2) {
		if (si > sub.N_MAX) {	/* part of outer halo in a FULL time step */
			dt = sub.totaltime;
		} else {
			dt = SaveDt;
		}

		while (si < N_LIMIT && star[si].interacted > 0) si++;
		bi = si + 1;
		if (bi > N_LIMIT)
			break;	/* ignore remaining stars if not paired */
		while (star[bi].interacted > 0) {
			bi++;
			if (bi > N_LIMIT)
				break;	/* ignore remaining stars if not paired */
		}
		if (bi > N_LIMIT)
			break;	/* ignore remaining stars if not paired */
		
		interactiondone = 0;
		k = si;
		kp = bi;
		
		/* if one of the objects is a binary, then check for binary-single interaction */
		/* changed this test to XOR since it will erroneously allow two binaries here */
		if ((star[k].binind > 0 && star[kp].binind == 0) || (star[k].binind == 0 && star[kp].binind > 0)) {
			/* make sure k is a binary.  if not, swap indices */
			if (star[k].binind > 0) {
			} else {
				sip = kp;
				kp = k;
				k = sip;
				bi = si + 1;	/* interchange k & kp */
			}

			r = star[k].r;
			rp = star[kp].r;
			rm = (r + rp) / 2.0;
			vr = star[k].vr;
			vt = star[k].vt;
			vrp = star[kp].vr;
			vtp = star[kp].vt;
			Dr = fabs(rp - r);
			m = star[k].m;
			mp = star[kp].m;
			
			/* Compute relative speed W */
			phi = rng_t113_dbl() * 2.0 * PI;
			v[1] = vt;
			v[2] = 0.0;
			v[3] = vr;
			vp[1] = vtp * cos(phi);
			vp[2] = vtp * sin(phi);
			vp[3] = vrp;

			for (j = 1; j <= 3; j++) w[j] = vp[j] - v[j];
			W = sqrt(sqr(w[1]) + sqr(w[2]) + sqr(w[3]));
			if (W == 0.0) {
				eprintf("Star %ld : W = 0 in perturb_stars_fewbody() - 2\n", si);
				eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
					si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
				exit_cleanly(1);
			}

			/* point of closest approach (used in cross section) */
			min_dist = 3.5 * binary[star[k].binind].a;

			/* spitzer eq. 6-15 for max impact parameter for min_dist */
			p_max = min_dist * sqrt(1.0 + 2.0*(m+mp)/((double) clus.N_STAR) / (min_dist*W*W));

			/* Computing local density */
			si_minus_p = si - p;
			si_plus_p = si + p + 1;

			if (si_minus_p < 0) {
				si_minus_p = 0;
				si_plus_p = 2 * p + 1;
			} else if (si_plus_p > N_LIMIT) {
				si_plus_p = N_LIMIT;
				si_minus_p = N_LIMIT - 2 * p - 1;
			}

			n_local = 2.0 * p * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0) - pow(star[si_minus_p].r, 3.0));

			/* Probability of binary-single collision P = PI*p_max^2*W*n*dt */
			P_enc = PI * p_max * p_max * W * dt * (1.0 * clus.N_STAR) / log(GAMMA * clus.N_STAR) * n_local / 1.0;
			if (P_enc > 1.0) {
				wprintf("P_enc = %g >= 1!\n", P_enc);
			}
			
			/* perform binary-single interaction */
			if (rng_t113_dbl() < P_enc) {
				if (nbs == 0) {
					fprintf(stdout, "perturb_stars_fewbody(): performing binary-single interaction");
					fprintf(logfile, "perturb_stars_fewbody(): performing binary-single interaction");
				}
				
				fprintf(stdout, " %ld", nbs);
				fflush(stdout);
                                fprintf(logfile, " %ld", nbs);
				
				/* increment local counter */
				nbs++;

				/* increment global counter */
				N_bs++;

				if (BINSINGLE_FEWBODY) {
					/* seed RNG so run is reproducible outside of this code */
					seed = rand();
					gsl_rng_set(rng, seed);
					
					/* masses should be in CGS */
					m0 = star[kp].m * madhoc * units.m;
					m10 = binary[star[k].binind].m1 * madhoc * units.m;
					m11 = binary[star[k].binind].m2 * madhoc * units.m;
					/* radii and semimajor axis should be in CGS */
					r0 = 0.0;
					r10 = 0.0;
					r11 = 0.0;
					a1 = binary[star[k].binind].a * units.l;
					e1 = binary[star[k].binind].e;
					/* v_inf should be in units of v_crit */
					vc = sqrt(binary[star[k].binind].m1 * binary[star[k].binind].m2 * \
						  (binary[star[k].binind].m1 + binary[star[k].binind].m2 + star[kp].m) / \
						  (binary[star[k].binind].a * (binary[star[k].binind].m1 + binary[star[k].binind].m2) * \
						   star[kp].m * ((double) clus.N_STAR)));
					
					vinf = W/vc;
					/* b should be in units of a */
					b = sqrt(rng_t113_dbl()) * p_max / binary[star[k].binind].a;
					
					/* calculate Monte-Carlo units */
					bs_sf_units.v = sqrt((m+mp)/(m*mp) * 
							     (binary[star[k].binind].m1 * binary[star[k].binind].m2 / binary[star[k].binind].a) / 
							     ((double) clus.N_STAR));
					bs_sf_units.l = binary[star[k].binind].a;
					bs_sf_units.t = bs_sf_units.l / bs_sf_units.v;
					bs_sf_units.m = bs_sf_units.l * sqr(bs_sf_units.v);
					bs_sf_units.E = bs_sf_units.m * sqr(bs_sf_units.v);
					
					/* print to binsingle file */
					gzprintf(binsinglefile, "***** id=%ld\n", N_bs);
					gzprintf(binsinglefile, "./binsingle --m0 %.9g --m10 %.9g --m11 %.9g --r0 %.9g --r10 %.9g --r11 %.9g --a1 %.9g --e1 %.9g --vinf %.9g --b %.9g --seed %ld\n",
						 m0/FB_CONST_MSUN, m10/FB_CONST_MSUN, m11/FB_CONST_MSUN, 
						 r0/FB_CONST_RSUN, r10/FB_CONST_RSUN, r11/FB_CONST_RSUN,
						 a1/FB_CONST_AU, e1, vinf, b, seed);
					gzprintf(binsinglefile, "init:\tm0=%.5g m10=%.5g m11=%.5g r0=%.5g r10=%.5g r11=%.5g\n",
						 m0/FB_CONST_MSUN, m10/FB_CONST_MSUN, m11/FB_CONST_MSUN, 
						 r0/FB_CONST_RSUN, r10/FB_CONST_RSUN, r11/FB_CONST_RSUN);
					gzprintf(binsinglefile, "init:\ta1=%.5g e1=%.5g vinf=%.5g b=%.5g bmax=%.5g\n",
						 a1/FB_CONST_AU, e1, vinf, b, p_max/binary[star[k].binind].a);
					
					/* call fewbody! */
					bs_retval = binsingle(&bs_t, m0, m10, m11, r0, r10, r11, a1, e1, vinf, b, &bs_fb_units, &bs_hier, rng);
					
					/* print to binsingle file */
					gzprintf(binsinglefile, "final:\tretval=%d nstar=%d nobj=%d t=%.5g tcpu=%.5g\n",
						 bs_retval.retval, bs_hier.nstar, bs_hier.nobj, bs_t, bs_retval.tcpu);
					gzprintf(binsinglefile, "final:\tDL=%.5g DL/Li=%.5g DE=%.5g DE/Ei=%.5g\n",
						 bs_retval.DeltaL, bs_retval.DeltaLfrac, bs_retval.DeltaE, bs_retval.DeltaEfrac);
					gzprintf(binsinglefile, "final:\tencounter %scomplete: %s (%s)\n",
						 bs_retval.retval==0?"NOT ":"", fb_sprint_hier(bs_hier, string1), fb_sprint_hier_hr(bs_hier, string2));
					
					/* set up axes */
					wp = sqrt(sqr(w[1]) + sqr(w[2]));
					if (wp == 0.0) {
						eprintf("FATAL: Star %ld : wp = 0 in perturb_stars_fewbody()\n", si);
						eprintf("FATAL: si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n", 
							si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
						exit_cleanly(1);
					}
					
					/* wx, wy, and wz are the x, y, and z axes (unit vectors) of the fewbody
					   coordinate system represented in the cluster frame */
					wx[0] = 1.0;
					wx[1] = w[1]/W;
					wx[2] = w[2]/W;
					wx[3] = w[3]/W;
					wy[0] = 1.0;
					wy[1] = -w[1] * w[3] / (wp * W);
					wy[2] = -w[2] * w[3] / (wp * W);
					wy[3] = wp / W;
					wz[0] = 1.0;
					wz[1] = w[2] / wp;
					wz[2] = -w[1] / wp;
					wz[3] = 0.0;
					
					/* vcm will be used later */
					for (j=1; j<=3; j++) vcm[j] = (m * v[j] + mp * vp[j])/(m + mp);
					
					/* alpha is the factor by which to scale the velocities, as an artificial
					   way of bringing the objects to infinity while conserving energy and angular momentum */
					alpha = sqrt(1.0 + fb_outerpetot(bs_hier.obj, bs_hier.nobj)/fb_outerketot(bs_hier.obj, bs_hier.nobj));
					
					/* the initial binding energy of the binary */
					BE = binary[star[k].binind].m1 * binary[star[k].binind].m2 * sqr(madhoc) / (2.0 * binary[star[k].binind].a);
					
					/* now do something with the Fewbody result */
					if (fabs(bs_retval.DeltaEfrac) > 0.01) {
						/* energy error; ignore for now */
						gzprintf(binsinglefile, "final:\toutcome=energy error\n");
						fprintf(stdout, "!");
						fprintf(logfile, "!");
						gzprintf(binsinglefile, "ERROR: Don't know how to deal with Fewbody outcome \"energy error\".\n");
					} else if (bs_retval.retval == 0) {
						/* bad outcome; ignore for now */
						gzprintf(binsinglefile, "final:\toutcome=stopped\n");
						fprintf(stdout, "!");
						fprintf(logfile, "!");
						gzprintf(binsinglefile, "ERROR: Don't know how to deal with Fewbody outcome \"stopped\".\n");
					} else {
						/* good outcomes */
						if (bs_hier.nstar == 3) {
							/* no collisions */
							if (bs_hier.nobj == 3) {
								/* ionization */
								gzprintf(binsinglefile, "final:\toutcome=ionization\n");
								
								/* destroy binary */
								kpp = destroy_binary(k);
								
								/* assign stars */
								/* FIXME: should be rpp=star[k].r, etc.? */
								m = star[k].m = bs_hier.obj[0]->m * bs_sf_units.m / madhoc;
								mp = star[kp].m = bs_hier.obj[1]->m * bs_sf_units.m / madhoc;
								mpp = star[kpp].m = bs_hier.obj[2]->m * bs_sf_units.m / madhoc;
								rpp = star[kp].r;
								star[kpp].r = rpp;
								star[kpp].phi = star[kp].phi;
								vrpp = star[kp].vr;
								vtpp = star[kp].vt;
								
								gzprintf(binsinglefile, "final:\tm0=%.6g m1=%.6g m2=%.6g\n", 
									 star[k].m * madhoc * units.m / FB_CONST_MSUN,
									 star[kp].m * madhoc * units.m / FB_CONST_MSUN,
									 star[kpp].m * madhoc * units.m / FB_CONST_MSUN);
								

								/* figure out new velocities */
								for (j=1; j<=3; j++) {
									vnew[j] = vcm[j] + bs_sf_units.v * alpha * 
										(bs_hier.obj[0]->v[0] * wx[j] + bs_hier.obj[0]->v[1] * wy[j]+ bs_hier.obj[0]->v[2] * wz[j]);
									vpnew[j] = vcm[j] + bs_sf_units.v * alpha * 
										(bs_hier.obj[1]->v[0] * wx[j] + bs_hier.obj[1]->v[1] * wy[j]+ bs_hier.obj[1]->v[2] * wz[j]);
									vppnew[j] = vcm[j] + bs_sf_units.v * alpha * 
										(bs_hier.obj[2]->v[0] * wx[j] + bs_hier.obj[2]->v[1] * wy[j]+ bs_hier.obj[2]->v[2] * wz[j]);
								}

								DBE = -BE;
								Delta_BE_bs += DBE;	/* total bin-bin energy generated in the timestep */
								DE_bs += DBE;	/* ongoing total bin-bin energy generated */
								
								/* set binary's global properties */
								vr_new = vnew[3];
								vt_new = sqrt(sqr(vnew[1]) + sqr(vnew[2]));
								vrp_new = vpnew[3];
								vtp_new = sqrt(sqr(vpnew[1]) + sqr(vpnew[2]));
								vrpp_new = vppnew[3];
								vtpp_new = sqrt(sqr(vppnew[1]) + sqr(vppnew[2]));
								
								/* recompute energies of binary and star */
								DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
								DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
								DeltaEpp = 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new - vrpp * vrpp - vtpp * vtpp);
								
								/* Calculate new energies by recomputing E = PE + KE using new velocity */
								star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
								star[k].J = r * vt_new;
								star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
								star[kp].J = rp * vtp_new;
								/* star[].phi is not yet computed for kpp, so use position of kp, already set in star[kpp].phi */
								star[kpp].E = star[kpp].phi + 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new);
								star[kpp].J = rpp * vtpp_new;
								
								/* set new velocities for both stars */
								star[k].vr = vr_new;
								star[k].vt = vt_new;
								star[kp].vr = vrp_new;
								star[kp].vt = vtp_new;
								star[kpp].vr = vrpp_new;
								star[kpp].vt = vtpp_new;
								
								/* now set the potential at new particle's position to zero */
								star[kpp].phi = 0.0;
								
								/* Binary-single interaction done; does "2" mean binary-single interaction? */
								interactiondone = 1;
								star[k].interacted = star[kp].interacted = star[kpp].interacted = 2;
							} else if (bs_hier.nobj == 2) {
								/* preservation or exchange */
								if (bs_hier.obj[0]->n == 2) {
									bid = 0;
									sid = 1;
								} else {
									bid = 1;
									sid = 0;
								}

								if (((bs_hier.obj[bid]->obj[0]->id[0] == 1)&&(bs_hier.obj[bid]->obj[1]->id[0] == 2))||
								    ((bs_hier.obj[bid]->obj[0]->id[0] == 2)&&(bs_hier.obj[bid]->obj[1]->id[0] == 1))) {
									gzprintf(binsinglefile, "final:\toutcome=preservation\n");
								} else {
									gzprintf(binsinglefile, "final:\toutcome=exchange\n");
								}
								for (j=1; j<=3; j++) {
									vnew[j] = vcm[j] + bs_sf_units.v * alpha * 
										(bs_hier.obj[bid]->v[0] * wx[j] + bs_hier.obj[bid]->v[1] * wy[j]+ bs_hier.obj[bid]->v[2] * wz[j]);
									vpnew[j] = vcm[j] + bs_sf_units.v * alpha * 
										(bs_hier.obj[sid]->v[0] * wx[j] + bs_hier.obj[sid]->v[1] * wy[j]+ bs_hier.obj[sid]->v[2] * wz[j]);
								}
								/* set binary's properties */
								binary[star[k].binind].m1 = bs_hier.obj[bid]->obj[0]->m * bs_sf_units.m / madhoc;
								binary[star[k].binind].m2 = bs_hier.obj[bid]->obj[1]->m * bs_sf_units.m / madhoc;
								star[k].m = binary[star[k].binind].m1 + binary[star[k].binind].m2;
								binary[star[k].binind].a = bs_hier.obj[bid]->a * bs_sf_units.l;
								binary[star[k].binind].e = bs_hier.obj[bid]->e;
								
								/* set star's properties */
								star[kp].m = bs_hier.obj[sid]->m * bs_sf_units.m / madhoc;
								
								/* print something to output file */
								gzprintf(binsinglefile, "final:\ta=%.5g e=%.5g\n",
									 binary[star[k].binind].a * units.l / FB_CONST_AU, 
									 binary[star[k].binind].e);
								gzprintf(binsinglefile, "final:\tm0=%.6g m1=%.6g m2=%.6g\n", 
									 binary[star[k].binind].m1 * madhoc * units.m / FB_CONST_MSUN,
									 binary[star[k].binind].m2 * madhoc * units.m / FB_CONST_MSUN,
									 star[kp].m * madhoc * units.m / FB_CONST_MSUN);

								DBE = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
									sqr(madhoc) / (2.0 * binary[star[k].binind].a) - BE;
								
								/* bookkeeping */
								Delta_BE_bs += DBE;
								DE_bs += DBE;
								
								vr_new = vnew[3];
								vt_new = sqrt(sqr(vnew[1]) + sqr(vnew[2]));
								vrp_new = vpnew[3];
								vtp_new = sqrt(sqr(vpnew[1]) + sqr(vpnew[2]));
								
								/* recompute energies of binary and star */
								DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
								DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
								/* Calculate new energies by recomputing E = PE + KE using new velocity */
								star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
								star[k].J = r * vt_new;
								star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
								star[kp].J = rp * vtp_new;
								
								/* set new velocities for both stars */
								star[k].vr = vr_new;
								star[k].vt = vt_new;
								star[kp].vr = vrp_new;
								star[kp].vt = vtp_new;
								
								/* binary-single interaction DONE */
								interactiondone = 1;
								star[k].interacted = star[kp].interacted = 2;
							} else {
								/* triple; ignore for now */
								gzprintf(binsinglefile, "final:\toutcome=triple\n");
								fprintf(stdout, "!");
								fprintf(logfile, "!");
								gzprintf(binsinglefile, "ERROR: Don't know how to deal with Fewbody outcome \"triple\".\n");
							}
						} else  {
							/* merger; ignore for now */
							gzprintf(binsinglefile, "final:\toutcome=merger\n");
							fprintf(stdout, "!");
							fprintf(logfile, "!");
							gzprintf(binsinglefile, "ERROR: Don't know how to deal with Fewbody outcome \"merger\".\n");
						}
					}
				} else {
					/*************************************************************/
					/* Simple recipes below this point                           */
					/*************************************************************/
					
					/* Compute energy generated from binary -- Delta BE  */
					BE = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
						sqr(madhoc) / 2.0 / binary[star[k].binind].a;
					
					for (j = 1; j <= N_TRY; j++) {
						DY = rng_t113_dbl() * 1.999 + 0.001;
						if (rng_t113_dbl() * 1.1 * bin_single_sigma(0.001) < bin_single_sigma(DY))
							break;
					}
					if (j == N_TRY + 1) {
						eprintf("N_TRY exceeded in bin-single cross section\n");
						exit_cleanly(1);
					}
					
					DBE = DY * BE;
					DBE1 = DBE / 3;	/* recoil energy of binary */
					DBE2 = DBE - DBE1;	/* recoil energy of star */
					
					/* Set new (smaller) semi-major axis for binary */
					binary[star[k].binind].a = binary[star[k].binind].m1 * binary[star[k].binind].m2 *
						sqr(madhoc) / 2.0 / (BE + DBE);
					
					Delta_BE_bs += DBE;	/* total bin-single energy generated in the timestep */
					DE_bs += DBE;	/* ongoing total bin-single energy generated */
					
					theta = acos(rng_t113_dbl() * 2.0 - 1.0);
					phi = 2 * PI * rng_t113_dbl();
					
					/* recoil of the binary */
					a = 1;
					b = 2 * (vr * cos(theta) + vt * sin(theta) * cos(phi));
					c = -2 * DBE1 / m * clus.N_STAR;
					del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;
					
					vr_new = vr + del_v * cos(theta);
					vt_new = sqrt(pow(vt + del_v * sin(theta) * cos(phi), 2.0) + \
						      pow(del_v * sin(theta) * sin(phi), 2.0));
					
					/* recoil of the star/binary */
					a = 1;
					b = 2 * (vrp * cos(theta) + vtp * sin(theta) * cos(phi));
					c = -2 * DBE2 / mp * clus.N_STAR;
					del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;
					
					vrp_new = vrp + del_v * cos(theta);
					vtp_new = sqrt(pow(vtp + del_v * sin(theta) * cos(phi), 2.0) + \
						       pow(del_v * sin(theta) * sin(phi), 2.0));
					
					/* recompute energies of binary and star */
					DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
					DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
					
					/* Calculate new energies by recomputing E = PE + KE using new velocity */
					star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
					star[k].J = r * vt_new;
					star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
					star[kp].J = rp * vtp_new;
					
					/* set new velocities for both stars */
					star[k].vr = vr_new;
					star[k].vt = vt_new;
					star[kp].vr = vrp_new;
					star[kp].vt = vtp_new;
					
					/* binary-single interaction DONE */
					interactiondone = 1;
					star[k].interacted = star[kp].interacted = 2;
				}
			} else {
				/* NO binary interaction due -- continue with relaxation step */
				interactiondone = 0;
				star[k].interacted = star[kp].interacted = 0;
			}
		} /* end of binary-single interactions */
		
		/***********************/
		/* two-body relaxation */
		/***********************/
		RepeatEncounter = 1;
		if (!interactiondone) {
			while (RepeatEncounter) {
				r = star[k].r;
				rp = star[kp].r;
				rm = (r + rp) / 2.0;
				vr = star[k].vr;
				vt = star[k].vt;
				vrp = star[kp].vr;
				vtp = star[kp].vt;
				Dr = fabs(rp - r);
				m = star[k].m;
				mp = star[kp].m;
				
				phi = rng_t113_dbl() * 2.0 * PI;
				v[1] = vt;
				v[2] = 0.0;
				v[3] = vr;
				vp[1] = vtp * cos(phi);
				vp[2] = vtp * sin(phi);
				vp[3] = vrp;
				
				for (j = 1; j <= 3; j++)
					w[j] = vp[j] - v[j];
				W = sqrt(w[1] * w[1] + w[2] * w[2] + w[3] * w[3]);
				
				if (W == 0.0) {
					eprintf("FATAL: Star %ld : W = 0 in perturb_stars_fewbody() - 3\n", si);
					eprintf("FATAL: si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
					exit_cleanly(1);
				}
				
				/* henon calculation of beta -- usually using p = 2 */
				l = sqrt((2.0 * rm * rm * Dr * clus.N_STAR) / ((p - 1.0) * W * dt));
				beta = 2.0 * atan((m + mp) / (W * W * l));
				
				/* Stodolkiewicz calculation of beta */
				si_minus_p = si - p;
				si_plus_p = si + p + 1;
				
				if (si_minus_p < 0) {
					si_minus_p = 0;
					si_plus_p = 2 * p + 1;
				} else if (si_plus_p > N_LIMIT) {
					si_plus_p = N_LIMIT;
					si_minus_p = N_LIMIT - 2 * p - 1;
				}
				
				Ai = 3.0 * p / (pow(star[si_plus_p].r, 3.0) - pow(star[si_minus_p].r, 3.0))
					* pow((m + mp), 2.0) / pow(W, 3.0);
				
				sin2beta = Ai * dt / clus.N_STAR;
				
				/* sometimes, sin2beta becomes > 1, so need to handle that differently */
				if (sin2beta <= 1) {	/* normal case -- only one encounter required */
					beta = 2.0 * asin(sqrt(sin2beta));
					if (beta > PI / 2)
						beta = PI - beta;
					RepeatEncounter = 0;
					dt = SaveDt;	/* reset dt to original value */
				} else {	/* abnormal case -- compute multiple encounters */
					beta = PI;
					sin2beta = 1.0;	/* use beta = PI for the first encounter */
					dt = dt / Ai;	/* reduce Dt by Ai for the next encounter */
					RepeatEncounter = 1;
				}
				
				wp = sqrt(w[1] * w[1] + w[2] * w[2]);
				if (wp == 0.0) {
					eprintf("FATAL: Star %ld : wp = 0 in perturb_stars_fewbody()\n", si);
					eprintf("FATAL: si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
					exit_cleanly(1);
				}
				
				w1[1] = w[2] * W / wp;
				w1[2] = -w[1] * W / wp;
				w1[3] = 0.0;
				w2[1] = -w[1] * w[3] / wp;
				w2[2] = -w[2] * w[3] / wp;
				w2[3] = wp;
				
				psi = rng_t113_dbl() * 2 * PI;
				for (j = 1; j <= 3; j++) {
					w_new[j] = w[j] * cos(beta) + w1[j] * sin(beta) * cos(psi) + w2[j] * sin(beta) * sin(psi);
				}
				
				for (j = 1; j <= 3; j++) {
					v_new[j] = v[j] - mp / (m + mp) * (w_new[j] - w[j]);
					vp_new[j] = vp[j] + m / (m + mp) * (w_new[j] - w[j]);
				}
				
				/* New velocities found */ 
				vr_new = v_new[3];
				vt_new = sqrt(v_new[1] * v_new[1] + v_new[2] * v_new[2]);
				vrp_new = vp_new[3];
				vtp_new = sqrt(vp_new[1] * vp_new[1] + vp_new[2] * vp_new[2]);
				
				/* when sin2beta > 1, encounter is repeated until sin2beta <= 1 */
				if (RepeatEncounter) {
					vr = vr_new;	/* assign new velocities for use in repeated encounter */
					vt = vt_new;
					vrp = vrp_new;
					vtp = vtp_new;
				} else {
					
				/******** Check to see if a STRONG interaction is due for these stars   *******/
				/* save value of beta due to 2-body relaxation */
				/*  beta_relax = beta ;	 */
				/*  local_density = 2*p / (4*PI/3) / (pow(star[si_plus_p].r, 3.0) - */
				/*                                         pow(star[si_minus_p].r, 3.0)); */
				/* number of interactions per unit area */
				/*  lambda = local_density * W * dt; */
				/*****************************************************************************/
					
					DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
					DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
					
					/* Calculate new energies by recomputing E = PE + KE using new velocity*/ 
					star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
					star[k].J = r * vt_new;
					star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
					star[kp].J = rp * vtp_new;

					/* set new velocities for both stars */
					star[k].vr = vr_new;
					star[k].vt = vt_new;
					star[kp].vr = vrp_new;
					star[kp].vt = vtp_new;
					
					star[k].interacted = star[kp].interacted = 1;
				}
			}
		} /* matches if(!interactiondone) */
		/** End IF interaction NOT done (relaxation step) **/
	}			/* End For-- next star */
	
	/* print newline */
	if (nbs) {
		fprintf(stdout, "\n");
		fflush(stdout);
		fprintf(logfile, "\n");
	}

	/************************************/
	/* Break binaries that are too wide */
	/************************************/
	for (si=1; si<=N_LIMIT; si++) {
		/* sub timestep voodoo */
		if (si > sub.N_MAX) {
			dt = sub.totaltime;
		} else {
			dt = SaveDt;
		}
		
		/* get star index of object in question */
		k = si;
		kb = star[k].binind;

		if (kb > 0) {
			/* calculate local number density of stars (single and binary) */
			si_minus_p = si - p;
			si_plus_p = si + p + 1;

			if (si_minus_p < 0) {
				si_minus_p = 0;
				si_plus_p = 2 * p + 1;
			} else if (si_plus_p > N_LIMIT) {
				/* this should probably be changed to clus.N_MAX instead of N_LIMIT */
				si_plus_p = N_LIMIT;
				si_minus_p = N_LIMIT - 2 * p - 1;
			}

			n_local = 2.0 * p * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0) - pow(star[si_minus_p].r, 3.0));

			r_max = pow(n_local, -1.0/3.0);
			
			/* destroy binary if too wide; the factor in front of r_max is ad hoc */
			if (binary[kb].a >= 1.0 * r_max) {
				/* to conserve energy, this binding energy will given to a field star below */
				BE = (binary[kb].m1 * binary[kb].m2 * sqr(madhoc)) / (2.0 * binary[kb].a);

				fprintf(stdout, "perturb_stars_fewbody(): breaking a binary: kb=%ld a=%g r_max=%g BE=%g\n", kb, binary[kb].a, r_max, BE);
				fprintf(logfile, "perturb_stars_fewbody(): breaking a binary: kb=%ld a=%g r_max=%g BE=%g\n", kb, binary[kb].a, r_max, BE);
				
				m = binary[kb].m1;
				mp = binary[kb].m2;
				r = star[k].r;
				rp = r;
				vr = star[k].vr;
				vt = star[k].vt;
				vrp = vr;
				vtp = vt;
				
				/* this destroys the binary and sets the new star's mass to binary.m2 and radius to SF_INFINITY */
				kp = destroy_binary(k);
				
				/* set masses, radii, and potential */
				star[k].m = m;
				star[kp].m = mp;
				star[k].vr = vr;
				star[k].vt = vt;
				star[kp].vr = vrp;
				star[kp].vt = vtp;
				star[kp].phi = star[k].phi;
				star[kp].r = rp;

				/* Calculate new energies by recomputing E = PE + KE using new velocity */
				star[k].E = star[k].phi + 0.5 * (sqr(vr) + sqr(vt));
				star[k].J = r * vt;
				star[kp].E = star[kp].phi + 0.5 * (sqr(vrp) + sqr(vtp));
				star[kp].J = rp * vtp;

				/* now set the potential at new particle's position to zero */
				star[kp].phi = 0.0;

				/* now give binary's binding energy to nearby field star */
				/* FIXME */
				
				/* FIXME */
			}
		}
	}
	
	/* free Fewbody memory */
	fb_free_hier(bs_hier);
	fb_free_hier(bb_hier);
}

/* the original perturb stars */
void perturb_stars(double dt)
{
	long si, N_LIMIT;
	double SaveDt, l;
	double W, v[4], vp[4], w[4], phi, psi, beta, wp, w1[4], w2[4];
	double v_new[4], vp_new[4], vr_new, vt_new, vrp_new, vtp_new;
	double r, rp, rm, Dr, m, mp, w_new[4];
	double DeltaE, DeltaEp, vr, vt, vrp, vtp, Ai;
	long p = 20, i, sip, k, kp, j, si_minus_p, si_plus_p, RepeatEncounter;
	double min_dist, p_max, P_enc, n_local, n_bin_local, del_v, a, b, c, theta;
	double BE, DBE, DBE1, DBE2, DBE3, rpp, vrpp, vtpp, mpp, vrpp_new, vtpp_new;
	double DeltaEpp, DY, BE1, BE2;
	long interactiondone, bi, bcount, i_nearest, kpp;
	double sin2beta;

	r = rp = m = 0; 	
	vr = vt = vrp = vtp = 0;
	P_enc = 0;			
	DY = 0;	 		
	sin2beta = 0.1;
	SaveDt = dt;		/* Original dt provided, saved for repeated encounters, where dt is changed */
	Delta_BE_bb = 0.0;	/* Total energy generated by binary-binary interactions */
	Delta_BE_bs = 0.0;	/* Total energy generated by binary-single interactions */
	clus.N_MAX_NEW = clus.N_MAX;	/* keeps track of stars from disrupted binaries */

	/* First loop over ALL binaries, and check for binary-binary interactions */
	if (sub.count == 0) {
		N_LIMIT = clus.N_MAX;	/* do FULL time step */
	} else {
		N_LIMIT = sub.N_MAX;	/* do sub step only */
	}

	for (si = 1; si <= N_LIMIT; si++) {
		if (si > sub.N_MAX) {	/* part of outer halo in a FULL time step */
			dt = sub.totaltime;
		} else {
			dt = SaveDt;
		}

		k = si;
		if (star[k].binind > 0 && star[k].interacted == 0) {
			/* Uninteracted binary -- so check for bin-bin interaction */

			/* Compute local number density of binaries -- find nearest 5 binaries
			   (or less), by looking out to the nearest 100 stars. 
			   Also, find nearest UNINTERACTED binary to interact with.
			 */
			bcount = 0;
			si_minus_p = si_plus_p = si;
			i_nearest = si;
			for (i = 1; i <= 100; i++) {
				if (si + i <= N_LIMIT && star[si + i].binind > 0) {
					bcount++;
					si_plus_p = si + i;
					if (i_nearest == si && star[si + i].interacted == 0) {
						i_nearest = si + i;
					}
				}
				if (si - i > 0 && star[si - i].binind > 0) {
					bcount++;
					si_minus_p = si - i;
					if (i_nearest == si && star[si - i].interacted == 0) {
						i_nearest = si - i;
					}
				}
				if (bcount > 10)
					break;	/* stop when 10 nearest binaries are found */
			}

			bcount++;	/* To account for the binary at si */
			kp = i_nearest;

			if (bcount == 1) {	/* No other binary found nearby - so set density = 0 */
				n_bin_local = 0.0;
				P_enc = 0.0;	/* set collision probability = 0 */
			}
			if (bcount == 2) {	/* only one other nearby binary found */
				n_bin_local = (bcount - 1) * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0)
									       - pow(star[si_minus_p].r, 3.0));
			} else {	/* in computing the density, DON'T count the boundary stars */
				n_bin_local = (bcount - 2) * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0)
									       - pow(star[si_minus_p].r, 3.0));
			}


			/* check for bin-bin interaction between star si & i_nearest */

			if (i_nearest != si && n_bin_local > 0) {

				r = star[k].r;
				rp = star[kp].r;
				rm = (r + rp) / 2.0;
				vr = star[k].vr;
				vt = star[k].vt;
				vrp = star[kp].vr;
				vtp = star[kp].vt;
				Dr = fabs(rp - r);
				m = star[k].m;
				mp = star[kp].m;

				/* Compute relative speed W */
				phi = rng_t113_dbl() * 2 * PI;
				v[1] = vt;
				v[2] = 0.0;
				v[3] = vr;
				vp[1] = vtp * cos(phi);
				vp[2] = vtp * sin(phi);
				vp[3] = vrp;

				for (j = 1; j <= 3; j++)
					w[j] = vp[j] - v[j];
				W = sqrt(w[1] * w[1] + w[2] * w[2] + w[3] * w[3]);

				if (W == 0.0) {
					eprintf("Star %ld : W = 0 in perturb_stars() - 1\n", si);
					eprintf(" si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
				}

				/* set distance of closest approach for collision based on softer binary */
				if (binary[star[k].binind].a > binary[star[kp].binind].a)
					min_dist = 2.0 * (binary[star[k].binind].a);
				else
					min_dist = 2.0 * (binary[star[kp].binind].a);

				/* Spitzer's expression for the cross section */
				p_max = sqrt(15.9 * (0.5*(m+mp)/clus.N_STAR) * min_dist / (W * W));

				/* Probability of bin-bin encounter P = pi*p_max^2*W*n*dt */
				P_enc = PI * p_max * p_max * W * dt * (1.0 * clus.N_STAR) / log(GAMMA * clus.N_STAR) * n_bin_local / 1.0;
				if (P_enc > 1.0) {
					wprintf("P_enc = %g >= 1!\n", P_enc);
				}
			}

			if (rng_t113_dbl() < P_enc) {	/* check if bin-bin interaction is DUE */

				/* DO interaction */
				fprintf(stdout, "\nbinary - binary interaction DUE \n");
				fprintf(logfile, "\nbinary - binary interaction DUE \n");
				N_bb++;

				/* Compute energy generated from binary -- Delta BE  */

				BE1 = binary[star[k].binind].m1 * binary[star[k].binind].m2 / clus.N_STAR / clus.N_STAR / 2.0 / binary[star[k].binind].a;
				BE2 = binary[star[kp].binind].m1 * binary[star[kp].binind].m2 / clus.N_STAR / clus.N_STAR / 2.0 / binary[star[kp].binind].a;
				BE = BE1 + BE2;

				for (j = 1; j <= N_TRY; j++) {
					DY = rng_t113_dbl() * 1.0;
					if (rng_t113_dbl() * 1.9 < 12.25 * DY / pow((1.0 + 3.5 * DY * DY), 2.75))
						break;
				}
				if (j == N_TRY + 1) {
					eprintf("N_TRY exceeded in bin-bin cross section\n");
					exit_cleanly(1);
				}
				DBE = DY * BE;
				DBE1 = DBE / 4.0;	/* recoil energy of binary */
				DBE2 = (DBE - DBE1) * rng_t113_dbl();	/* recoil energy of first star */
				DBE3 = DBE - DBE1 - DBE2;	/* recoil energy of second star */

				/* check which binary is harder */
				if (BE1 < BE2) {	/* binary kp is harder than k */
					bi = k;
					k = kp;
					kp = bi;	/* so interchange binary k & kp */
					BE = BE1;
					BE1 = BE2;
					BE2 = BE;
					BE = BE1 + BE2;
					r = star[k].r;
					rp = star[kp].r;
					rm = (r + rp) / 2.0;
					vr = star[k].vr;
					vt = star[k].vt;
					vrp = star[kp].vr;
					vtp = star[kp].vt;
					Dr = fabs(rp - r);
					m = star[k].m;
					mp = star[kp].m;
				}

				/* Set new (smaller) semi-major axis for binary k (harder binary) 
				   New BE = original(BE1+BE2)+DBE = 2*DBE + DBE = 3*DBE 
				 */
				binary[star[k].binind].a =
				    binary[star[k].binind].m1 * binary[star[k].binind].m2 / clus.N_STAR / clus.N_STAR / 2.0 / (BE1 + BE2 + DBE);

				/* binding energy of soft binary is lost since it is destroyed.
				   But it is compensated by harder binary getting harder. So total BE
				   does not decrease due to the destruction of the binary. In addition,
				   more translational energy 0.5*(BE1+BE2) is released by the harder binary.
				 */
				Delta_BE_bb += DBE;	/* total bin-bin energy generated in the timestep */
				DE_bb += DBE;	/* ongoing total bin-bin energy generated */

				/* An additional second star is also given energy */
				clus.N_STAR_NEW++;
				clus.N_MAX_NEW++;
				bi = clus.N_MAX_NEW;	/* new star */
				kpp = bi = clus.N_STAR_NEW;	/* new star is placed at the end for now */
				star[kpp].binind = 0; /* binary is destroyed */
				star[kpp].m = binary[star[kp].binind].m2;

				/* use same positions and velocities as star kp */
				
				star[kpp].r = star[kp].r;
				star[kpp].phi = 0.0;
				star[kpp].vr = star[kp].vr;
				star[kpp].vt = star[kp].vt;	/* OK to assign velocities though */

				rpp = star[kp].r;
				vrpp = star[kpp].vr;
				vtpp = star[kpp].vt;
				mpp = star[kpp].m;

				/* binary kp is destroyed */
				mp = star[kp].m = binary[star[kp].binind].m1;	/* keep first star of the binary as single */
				/* label binary kp as destroyed */
				star[kp].binind = 0;

				/*********** compute recoil velocities - binary-binary int **********/

				theta = acos(rng_t113_dbl() * 2.0 - 1.0);
				phi = 2 * PI * rng_t113_dbl();

				/* recoil of the binary */
				a = 1;
				b = 2 * (vr * cos(theta) + vt * sin(theta) * cos(phi));
				c = -2 * DBE1 / m * clus.N_STAR;
				del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;

				vr_new = vr + del_v * cos(theta);
				vt_new = sqrt(pow(vt + del_v * sin(theta) * cos(phi), 2.0) +
					      pow(del_v * sin(theta) * sin(phi), 2.0));

				/* recoil of the star */
				a = 1;
				b = 2 * (vrp * cos(theta) + vtp * sin(theta) * cos(phi));
				c = -2 * DBE2 / mp * clus.N_STAR;
				del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;

				vrp_new = vrp + del_v * cos(theta);
				vtp_new = sqrt(pow(vtp + del_v * sin(theta) * cos(phi), 2.0) +
					       pow(del_v * sin(theta) * sin(phi), 2.0));

				/* recoil of the second star */
				a = 1;
				b = 2 * (vrpp * cos(theta) + vtpp * sin(theta) * cos(phi));
				c = -2 * DBE3 / mpp * clus.N_STAR;
				del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;

				vrpp_new = vrpp + del_v * cos(theta);
				vtpp_new = sqrt(pow(vtpp + del_v * sin(theta) * cos(phi), 2.0) +
						pow(del_v * sin(theta) * sin(phi), 2.0));


				/* recompute energies of binary and star */

				DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
				DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
				DeltaEpp = 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new - vrpp * vrpp - vtpp * vtpp);

				/*      Calculate new energies by recomputing E = PE + KE using new velocity
				 */ star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
				star[k].J = r * vt_new;
				star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
				star[kp].J = rp * vtp_new;
				/* star[].phi is not yet computed for kpp, so use position of kp */
				star[kpp].E = star[kp].phi + 0.5 * (vrpp_new * vrpp_new + vtpp_new * vtpp_new);
				star[kpp].J = rpp * vtpp_new;

				/* set new velocities for both stars 
				 */
				star[k].vr = vr_new;
				star[k].vt = vt_new;
				star[kp].vr = vrp_new;
				star[kp].vt = vtp_new;
				star[kpp].vr = vrpp_new;
				star[kpp].vt = vtpp_new;

				/* binary-binary interaction DONE */
				star[k].interacted = star[kp].interacted = star[kpp].interacted = 3;

			} else {
				/* NO binary-binary interaction due... so label binaries uninteracted.
				   It is possible for k==kp if i_nearest = si, i.e., no nearby bin was found.
				 */
				star[k].interacted = star[kp].interacted = 0;
			}


		}
		/* End IF (uninteracted binary) */
	}			/* End For loop (over all stars to look for uninteracted binaries) */




/**** Compute binary-single and single-single (2-body relaxation) interactions ****/

	for (si = 1; si <= N_LIMIT; si += 2) {

		if (si > sub.N_MAX) {	/* part of outer halo in a FULL time step */
			dt = sub.totaltime;
		} else {
			dt = SaveDt;
		}

		while (si < N_LIMIT && star[si].interacted > 0) {
			si++;
		}
		bi = si + 1;
		if (bi > N_LIMIT)
			break;	/* ignore remaining stars if not paired */
		while (star[bi].interacted > 0) {
			bi++;
			if (bi > N_LIMIT)
				break;	/* ignore remaining stars if not paired */
		}
		if (bi > N_LIMIT)
			break;	/* ignore remaining stars if not paired */

		interactiondone = 0;
		k = si;
		kp = bi;

		/* if one of the objects is a binary, then check for binary-single interaction */
		/* changed this test to XOR since it will erroneously allow two binaries here */
		if ((star[k].binind > 0 && star[kp].binind == 0) || (star[k].binind == 0 && star[kp].binind > 0)) {
			/* make sure k is a binary.  if not, swap indices */
			if (star[k].binind > 0) {
			} else {
				sip = kp;
				kp = k;
				k = sip;
				bi = si + 1;	/* interchange k & kp */
			}

			r = star[k].r;
			rp = star[kp].r;
			rm = (r + rp) / 2.0;
			vr = star[k].vr;
			vt = star[k].vt;
			vrp = star[kp].vr;
			vtp = star[kp].vt;
			Dr = fabs(rp - r);
			m = star[k].m;
			mp = star[kp].m;

			/* Compute relative speed W */
			phi = rng_t113_dbl() * 2 * PI;
			v[1] = vt;
			v[2] = 0.0;
			v[3] = vr;
			vp[1] = vtp * cos(phi);
			vp[2] = vtp * sin(phi);
			vp[3] = vrp;

			for (j = 1; j <= 3; j++)
				w[j] = vp[j] - v[j];
			W = sqrt(w[1] * w[1] + w[2] * w[2] + w[3] * w[3]);

			if (W == 0.0) {
				eprintf("Star %ld : W = 0 in perturb_stars() - 2\n", si);
				eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
					si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
				exit_cleanly(1);
			}

			/* check for binary-single interaction */
			min_dist = 3.5 * binary[star[k].binind].a;

			/* spitzer eq. 6-15 for max impact parameter for min_dist */
			p_max = min_dist * sqrt(1.0 + 2.0*(m+mp)/((double) clus.N_STAR) / (min_dist*W*W));
			
			/* Computing local density */
			si_minus_p = si - p;
			si_plus_p = si + p + 1;

			if (si_minus_p < 0) {
				si_minus_p = 0;
				si_plus_p = 2 * p + 1;
			} else if (si_plus_p > N_LIMIT) {
				si_plus_p = N_LIMIT;
				si_minus_p = N_LIMIT - 2 * p - 1;
			}

			n_local = 2.0 * p * 3.0 / 4.0 / PI / (pow(star[si_plus_p].r, 3.0) - pow(star[si_minus_p].r, 3.0));

			/* Probability of binary-single collision P = pi*p_max^2*W*n*dt */
			P_enc = PI * p_max * p_max * W * dt * (1.0 * clus.N_STAR) / log(GAMMA * clus.N_STAR) * n_local / 1.0;
			if (P_enc > 1.0) {
				wprintf("P_enc = %g >= 1!\n", P_enc);
			}
			
			if (rng_t113_dbl() < P_enc) {	/* binary-single Collision DUE */
				/* DO collision */
				fprintf(stdout, "\nbinary - single interaction DUE \n");
				fprintf(logfile, "\nbinary - single interaction DUE \n");
				N_bs++;

				/* Compute energy generated from binary -- Delta BE  */
				BE = binary[star[k].binind].m1 * binary[star[k].binind].m2 / clus.N_STAR / clus.N_STAR / 2.0 / binary[star[k].binind].a;

				for (j = 1; j <= N_TRY; j++) {
					DY = rng_t113_dbl() * 1.999 + 0.001;
					if (rng_t113_dbl() * 1.1 * bin_single_sigma(0.001) < bin_single_sigma(DY))
						break;
				}
				if (j == N_TRY + 1) {
					eprintf("N_TRY exceeded in bin-single cross section\n");
					exit_cleanly(1);
				}

				DBE = DY * BE;
				DBE1 = DBE / 3;	/* recoil energy of binary */
				DBE2 = DBE - DBE1;	/* recoil energy of star */

				/* Set new (smaller) semi-major axis for binary */
				binary[star[k].binind].a = binary[star[k].binind].m1 * binary[star[k].binind].m2 / clus.N_STAR / clus.N_STAR / 2.0 / (BE + DBE);

				Delta_BE_bs += DBE;	/* total bin-single energy generated in the timestep */
				DE_bs += DBE;	/* ongoing total bin-single energy generated */

				theta = acos(rng_t113_dbl() * 2.0 - 1.0);
				phi = 2 * PI * rng_t113_dbl();

				/* recoil of the binary */
				a = 1;
				b = 2 * (vr * cos(theta) + vt * sin(theta) * cos(phi));
				c = -2 * DBE1 / m * clus.N_STAR;
				del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;

				vr_new = vr + del_v * cos(theta);
				vt_new = sqrt(pow(vt + del_v * sin(theta) * cos(phi), 2.0) +
					      pow(del_v * sin(theta) * sin(phi), 2.0));

				/* recoil of the star/binary */
				a = 1;
				b = 2 * (vrp * cos(theta) + vtp * sin(theta) * cos(phi));
				c = -2 * DBE2 / mp * clus.N_STAR;
				del_v = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 / a;

				vrp_new = vrp + del_v * cos(theta);
				vtp_new = sqrt(pow(vtp + del_v * sin(theta) * cos(phi), 2.0) +
					       pow(del_v * sin(theta) * sin(phi), 2.0));


				/* recompute energies of binary and star */

				DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
				DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);

				/*      Calculate new energies by recomputing E = PE + KE using new velocity
				 */ star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
				star[k].J = r * vt_new;
				star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
				star[kp].J = rp * vtp_new;

				/* set new velocities for both stars 
				 */
				star[k].vr = vr_new;
				star[k].vt = vt_new;
				star[kp].vr = vrp_new;
				star[kp].vt = vtp_new;

				/* binary-single interaction DONE */
				interactiondone = 1;
				star[k].interacted = star[kp].interacted = 2;

			} else {
				/* NO binary interaction due -- continue with relaxation step */
				interactiondone = 0;
				star[k].interacted = star[kp].interacted = 0;
			}
		}


		/* If not binary-binary or binary-single interaction, do regular relaxation step. */
		RepeatEncounter = 1;
		if (!interactiondone) {
			while (RepeatEncounter) {
				r = star[k].r;
				rp = star[kp].r;
				rm = (r + rp) / 2.0;
				vr = star[k].vr;
				vt = star[k].vt;
				vrp = star[kp].vr;
				vtp = star[kp].vt;
				Dr = fabs(rp - r);
				m = star[k].m;
				mp = star[kp].m;
				
				phi = rng_t113_dbl() * 2.0 * PI;
				v[1] = vt;
				v[2] = 0.0;
				v[3] = vr;
				vp[1] = vtp * cos(phi);
				vp[2] = vtp * sin(phi);
				vp[3] = vrp;
				
				for (j = 1; j <= 3; j++)
					w[j] = vp[j] - v[j];
				W = sqrt(w[1] * w[1] + w[2] * w[2] + w[3] * w[3]);
				
				if (W == 0.0) {
					eprintf("Star %ld : W = 0 in perturb_stars() - 3\n", si);
					eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
					exit_cleanly(1);
				}
				
				/* henon calculation of beta -- usually using p = 2 */
				l = sqrt((2.0 * rm * rm * Dr * clus.N_STAR) / ((p - 1.0) * W * dt));
				beta = 2.0 * atan((m + mp) / (W * W * l));
				
				/* Stodolkiewicz calculation of beta */
				si_minus_p = si - p;
				si_plus_p = si + p + 1;
				
				if (si_minus_p < 0) {
					si_minus_p = 0;
					si_plus_p = 2 * p + 1;
				} else if (si_plus_p > N_LIMIT) {
					si_plus_p = N_LIMIT;
					si_minus_p = N_LIMIT - 2 * p - 1;
				}
				
				Ai = 3.0 * p / (pow(star[si_plus_p].r, 3.0) - pow(star[si_minus_p].r, 3.0))
					* pow((m + mp), 2.0) / pow(W, 3.0);
				
				sin2beta = Ai * dt / clus.N_STAR;
				
				/* sometimes, sin2beta becomes > 1, so need to handle that differently */
				if (sin2beta <= 1) {	/* normal case -- only one encounter required */
					beta = 2.0 * asin(sqrt(sin2beta));
					if (beta > PI / 2)
						beta = PI - beta;
					RepeatEncounter = 0;
					dt = SaveDt;	/* reset dt to original value */
				} else {	/* abnormal case -- compute multiple encounters */
					beta = PI;
					sin2beta = 1.0;	/* use beta = pi for the first encounter */
					dt = dt / Ai;	/* reduce Dt by Ai for the next encounter */
					RepeatEncounter = 1;
				}
				
				wp = sqrt(w[1] * w[1] + w[2] * w[2]);
				if (wp == 0.0) {
					eprintf("Star %ld : wp = 0 in perturb_stars()\n", si);
					eprintf("si = %5ld  r = %.6g  vr = %.6G  vt = %.6g  rp = %.6G  vrp = %.6g  vtp = %.6g\n",
						si, star[k].r, star[k].vr, star[k].vt, star[kp].r, star[kp].vr, star[kp].vt);
					exit_cleanly(2);
				}
				
				w1[1] = w[2] * W / wp;
				w1[2] = -w[1] * W / wp;
				w1[3] = 0.0;
				w2[1] = -w[1] * w[3] / wp;
				w2[2] = -w[2] * w[3] / wp;
				w2[3] = wp;
				
				psi = rng_t113_dbl() * 2 * PI;
				for (j = 1; j <= 3; j++) {
					w_new[j] = w[j] * cos(beta) + w1[j] * sin(beta) * cos(psi) + w2[j] * sin(beta) * sin(psi);
				}
				
				for (j = 1; j <= 3; j++) {
					v_new[j] = v[j] - mp / (m + mp) * (w_new[j] - w[j]);
					vp_new[j] = vp[j] + m / (m + mp) * (w_new[j] - w[j]);
				}
				
				/* New velocities found */ 
				vr_new = v_new[3];
				vt_new = sqrt(v_new[1] * v_new[1] + v_new[2] * v_new[2]);
				vrp_new = vp_new[3];
				vtp_new = sqrt(vp_new[1] * vp_new[1] + vp_new[2] * vp_new[2]);
				
				/* when sin2beta > 1, encounter is repeated until sin2beta <= 1 */
				if (RepeatEncounter) {
					vr = vr_new;	/* assign new velocities for use in repeated encounter */
					vt = vt_new;
					vrp = vrp_new;
					vtp = vtp_new;
				} else {
					
				/******** Check to see if a STRONG interaction is due for these stars   *******/
				/* save value of beta due to 2-body relaxation */
				/*  beta_relax = beta ;	 */
				/*  local_density = 2*p / (4*pi/3) / (pow(star[si_plus_p].r, 3.0) - */
				/*                                         pow(star[si_minus_p].r, 3.0)); */
				/* number of interactions per unit area */
				/*  lambda = local_density * W * dt; */
				/*****************************************************************************/
					
					DeltaE = 0.5 * (vr_new * vr_new + vt_new * vt_new - vr * vr - vt * vt);
					DeltaEp = 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new - vrp * vrp - vtp * vtp);
					
					/* Calculate new energies by recomputing E = PE + KE using new velocity*/ 
					star[k].E = star[k].phi + 0.5 * (vr_new * vr_new + vt_new * vt_new);
					star[k].J = r * vt_new;
					star[kp].E = star[kp].phi + 0.5 * (vrp_new * vrp_new + vtp_new * vtp_new);
					star[kp].J = rp * vtp_new;

					/* set new velocities for both stars */
					star[k].vr = vr_new;
					star[k].vt = vt_new;
					star[kp].vr = vrp_new;
					star[kp].vt = vtp_new;
					
					
					star[k].interacted = star[kp].interacted = 1;
				}
			}
		} /* matches if(!interactiondone) */
		/** End IF interaction NOT done (relaxation step) **/
	}			/* End For-- next star */
}
